[{"tag":"p","original":" This tutorial lists the frequently asked coding questions in Interviews. All the questions are coded with the believed-to-be-best codes in the C programming language. All the questions are collected from different resources on the internet. ","result":"In this guide, we will provide a list of commonly asked programming interview questions. Each question is accompanied by a code example written in C, which is believed to be the most optimal solution. These questions have been sourced from various online resources."},{"tag":"p","original":" First, an Array is a homogeneous and static Data Structure that stores elements in contiguous memory locations. We use indexes to access the elements of the array. Positive indexing starts from (0 to size - 1), and negative indexing starts from the end of the array from (-1 to -size). The name of an Array is treated as a pointer by the C compiler, pointing to the first element of the data structure. Hence, we can use pointer arithmetic to access Array elements. ","result":"An Array is a type of Data Structure that stores items of the same type together in a static and homogeneous manner. These elements are stored next to each other in memory and can be accessed using numerical indexes. The first element in the array is accessed using index 0, while the last element is accessed using index size -1. The name of an array acts as a pointer to its first element, allowing for the use of pointer arithmetic to access other elements."},{"tag":"strong","original":" Now, let us dive into some coding questions: ","result":"Sure, here's a rephrased version of the content:\n\nLet's explore some typical coding questions that you may encounter during interviews, which will help you prepare for your next job interview in the tech industry."},{"tag":"p","original":"  At least one such element will exist in an array, called the  \"Peak element\".  We can use many approaches, like iterating the whole array, finding the largest element in the array, etc., to find the element. Here, we'll use the best approach. Remember that we are just asked to write a function. Hence, we can take the array and its size as the two parameters and write the function: ","result":"In an array, there exists at least one element which is greater than or equal to its adjacent elements, also known as the \"Peak element\". There are several methods to find this element such as, iterating through the entire array and identifying the largest element, however the best approach will be used. As we are only required to write a function, the function can take the array and its size as parameters in order to find the peak element."},{"tag":"p","original":" We need an efficient code. It takes O(n) time if we iterate the whole array. But we don't need all the peak elements; we need one. We have to keep searching for the element eliminating parts of the array. ","result":"An optimized code is required to find the peak element in an array. While iterating the whole array takes O(n) time, we only need to find one peak element instead of all of them. Thus, parts of the array can be eliminated while searching for the element to increase efficiency."},{"tag":"p","original":" We used the Binary search algorithm to eliminate the parts of the array we don't have to traverse. Even though the array isn't sorted, we'll have to find one locally large element. ","result":"The approach used in the solution was the Binary search method. This algorithm was employed to reduce the number of array elements that need to be traversed during the search process. Despite the fact that the array may not be in a sorted order, the aim was to identify a locally large element."},{"tag":"p","original":"  We can declare two variables,  l = 0, h = (n - 1) . We can keep swapping the values in the array at l and h by incrementing l and decrementing h till both l and h reach the middle element or till both overtake each other. ","result":"To swap elements in an array, we can initialize two variables - one with the value of 0, and the other with the value of (n - 1), where n is the length of the array. We can then swap values in the array by incrementing the first variable and decrementing the second variable until they reach the middle element or pass each other."},{"tag":"p","original":" We're asked to traverse the array only once. We need to use two pointers/ variables to traverse the array. We have two options here: ","result":"To solve the problem, it's required to iterate through the array only once. This can be achieved by using two pointers or variables to traverse the array. Two approaches are available to handle this situation:"},{"tag":"li","original":" Using two variables pointing from the beginning of the array ","result":"Reword the text to avoid using the same language and sentence structure as the original source while retaining the same meaning. \n\nFor example:\n- Two variables are utilized to reference the start of the array. \n- A pair of pointers is employed to indicate the beginning of the array. \n- The array's starting point is indicated using two variable references."},{"tag":"li","original":" Using one variable pointing from the beginning and the other from the end. ","result":"The suggestion is to utilize two variables, one counting from the start and the other counting from the end."},{"tag":"strong","original":" Variables from both ends of the array: ","result":"Reword: \"Elements located at the beginning and the end of an array are considered as variables.\""},{"tag":"p","original":" We use two variables l and h storing the indexes of the array's first and last elements, respectively. We want to set 0's followed by 1's in the array. The elements traversed by l from the beginning should be 0's, and the elements from the end visited by h should be 1s. We need to swap the elements if l finds a 1 or h finds a 0. ","result":"To arrange the elements in an array with 0's first followed by 1's, we can use two variables - l and h - that store the indexes of the first and last elements, respectively. The aim is to traverse the elements from both ends, with l starting from the beginning and h from the end, to ensure that the 0's are placed before the 1's. If l comes across a 1 or h encounters a 0, the elements need to be swapped in order to maintain the correct order."},{"tag":"strong","original":" Both variables from the beginning of the array: ","result":"Reworded: \n\nThe two variables located at the start of the array:"},{"tag":"p","original":" We want to arrange 0's followed by 1's in the array. We'll use two variables, both traversing from the beginning of the array. One variable is used to visit the elements and check the values, and the other is dedicated to staying at an index. The logic here is that whenever the visiting variable finds a 0, we should swap the elements at two variables. ","result":"To arrange 0's before 1's in an array, we can use two variables. One variable will be used to traverse the array and check the values of each element, while the other variable will stay at a fixed index. The approach is to swap the elements at the two variables whenever the traversal variable encounters a 0. This way, we can ensure that the 0's are placed before the 1's in the array."},{"tag":"p","original":" Observe that in both methods, we traversed the whole array only once. ","result":"Both methods involve iterating through the entire array once."},{"tag":"p","original":" We can solve this problem like the above problem. We're given an integer array with positive and negative integers arranged randomly. We're supposed to arrange the array in the order of positive integers followed by negative or negative integers followed by positive integers. ","result":"To solve the given problem, we can use a similar approach as we did in the problem mentioned earlier. The problem involves an array of integers containing positive and negative values arranged in a random order. The task is to rearrange the array in such a way that all positive integers come before negative integers or vice versa."},{"tag":"p","original":" In the above problem, we wrote code to arrange an array with 0's followed by 1's. Here, we need to use the same algorithm to arrange an array with negative elements followed by positive elements. ","result":"The previous task involved coding to organize an array with 0's first followed by 1's. Similarly, for this task, we are required to apply the same technique to sort an array such that negative elements appear first, followed by positive elements."},{"tag":"strong","original":" Variables from both ends of the array: ","result":"Reword this statement to avoid plagiarism:\n\n\"Variables have been extracted from both the beginning and end of the array.\""},{"tag":"strong","original":" Both variables from the beginning of the array: ","result":"Rewritten: \n\nThe two initial variables located at the start of the array:"},{"tag":"p","original":"  We're given an integer array and an integer k. We need to find the maximum sum possible in the array when elements in k consecutive indexes are added. Using nested loops, we can use the brute-force approach to check all the k-sized possible sub-arrays in the array. It could be more efficient. Another notable technique we can use is the \" Sliding window technique \". ","result":"The goal is to find the highest possible sum in an array of integers by adding the elements in consecutive indexes of size k. One way to approach this is by nested loops, which allows us to check all possible k-sized sub-arrays in the array. However, this method may not be the most efficient. A more effective technique to consider is the \"Sliding window technique\"."},{"tag":"p","original":" We take the value of k from the user, and the concept here is that we create a window of size k, and we'll keep sliding it by a unit index. ","result":"To solve the problem, we can prompt the user to enter the value of k. Then, we can implement a sliding window approach where a window of size k is created and shifted one index at a time. This allows us to analyze the data in a systematic and efficient manner."},{"tag":"p","original":" Suppose we need the maximum sum of 2 consecutive indexes, create a 2-sized window, and keep sliding (traversing) it throughout the array. We'll find the sum of elements of each window and return the maximum sum: ","result":"To find the maximum sum of 2 consecutive indices in an array, we can create a window of size 2 and slide it over the array. As we move the window, we add up the elements within the window and keep track of the maximum sum found so far. Finally, we return the maximum sum obtained."},{"tag":"p","original":"  We're given an array of only positive numbers and the required sum. We need to find a sub-array with elements adding to the given sum. There can be more than one such sub-array. We can use nested loops and check the sum of all possible sub-arrays, but it could be more efficient. Hence, we can use the above \" Sliding window technique .\" ","result":"The task is to find a sub-array within an array of only positive numbers that adds up to a given sum. Rather than using slower nested loops to check all possible sub-arrays, a more efficient approach is to use the sliding window technique. This involves starting with a window of the smallest possible size that equals or exceeds the required sum, and then \"sliding' the window along the array, updating the sum as needed and checking if it matches the required sum."},{"tag":"p","original":" It is given that all the elements in the array are positive. So, if there is a sub-array with a sum greater than the given sum, that's it. We need to leave the elements as they are. Hence, we can use this condition if the array also has negative elements; we cannot use the sliding window technique in all cases as the sum keeps changing. ","result":"Assuming that every element in the array is positive, we can use the sliding window technique to find a sub-array with a sum equal to the given sum. However, if there are negative elements in the array, this method might not work as the sum will keep changing. In cases where a sub-array with a greater sum exists in the array, we should not disturb the elements of the array."},{"tag":"li","original":" Keep adding elements to the window/ sub-array until the sum of elements is less than the given sum. ","result":"Continuously include elements one by one in the sub-array or window until their sum becomes less than the specified sum."},{"tag":"li","original":" If the sum exceeds the given sum, remove elements from the start of the window. ","result":"If the total of the elements within the window is greater than the specified sum, then the earliest elements in the window should be removed."},{"tag":"p","original":" We're given a sorted array and an integer. Our task is to find the number of occurrences of the integer in the array. It is a simple problem. We can solve it using any search algorithm we want. ","result":"The problem at hand is to determine the number of times an integer appears in a given sorted array. The solution involves applying any search algorithm to the array."},{"tag":"p","original":" We can solve the problem using the linear search or binary search. It is an optimization of traditional binary sort for better efficiency. But, we need to use an improved binary search algorithm to solve the problem in O(Log n) time. ","result":"There are different approaches to solving the given problem, such as linear search or binary search. However, for better efficiency, an enhanced version of binary search algorithm can be employed, which solves the problem in O(Log n) time."},{"tag":"li","original":" Find the index of the first occurrence of the integer using Binary sort ","result":"Reword the following text to remove any instances of plagiarism:\n\n\"Locate the initial instance of the integer by using a binary search algorithm.\""},{"tag":"li","original":" Find the index of the last occurrence of the integer using Binary sort ","result":"Reword the following text to avoid plagiarism: \n\nOriginal text: \"Find the index of the last occurrence of the integer using Binary sort.\"\n\nRephrased: Determine the position of the final instance of the integer using Binary sort."},{"tag":"li","original":" Return count = last index - first index + 1 ","result":"The statement \"return count = last index - first index + 1\" can be rephrased in different ways, such as \"The quantity of items is calculated by subtracting the first index from the last index and then adding one,\" or \"To determine the number of elements, simply add one to the difference between the last index and the first index.\""},{"tag":"p","original":" The whole logic lies in the relation between LCM and GCD of two numbers. Suppose a and b are the two numbers: ","result":"The concept is based on how the Lowest Common Multiple (LCM) and Greatest Common Divisor (GCD) of two numbers are related. Let the two numbers be a and b."},{"tag":"p","original":" a * b = LCM (a, b) * GCD (a, b) ","result":"The result of multiplying two numbers is equal to the product of their least common multiple and greatest common divisor."},{"tag":"p","original":" LCM (a, b) = a * b / GCD (a, b) ","result":"The formula to find the Least Common Multiple of two numbers a and b, states that it is equal to the product of the two numbers divided by their Greatest Common Divisor."},{"tag":"p","original":" To find the sum of all the number's digits and reverse them, we need to separate them from the number. We can access the digits of a number using division and modulus with multiples of 10: ","result":"We can extract the digits of a number by using division and modulus with multiples of 10. This helps us to calculate the sum of all the digits, which we can then reverse."},{"tag":"strong","original":" Logic to check if a given year is a leap year or not: ","result":"Algorithm to verify whether a specified year is a leap year or not:"},{"tag":"li","original":" A multiple of 400 or ","result":"A number that is divisible by 400 or a product of 400 and any other number."},{"tag":"li","original":" Multiple of 4 and not a multiple of 100 ","result":"A number that is divisible by 4 but is not divisible by 100."},{"tag":"a","original":" Spring Boot Interview Questions ","result":"The following are some questions that may be asked during an interview focusing on Spring Boot."},{"tag":"a","original":" C Programming Interview Questions ","result":"Here are some interview questions for a C programming role."},{"tag":"a","original":" Data Structure Interview Questions ","result":"Here are some interview questions related to data structures."},{"tag":"a","original":" Manual Testing Interview Questions ","result":"Revise the given text to avoid copying it word-for-word: \n\n\"Manual Testing Interview Questions\" is a topic that may come up during job interviews for software testing positions. Since manual testing involves manually verifying that software meets predetermined criteria and behaves as expected, interviewers often ask questions to assess candidates' knowledge of testing methodologies, testing techniques, and testing tools. Candidates who are well-prepared and able to communicate effectively may have an advantage in the interview process."}]