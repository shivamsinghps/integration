[{"tag":"p","original":" A list of top frequently asked C++ interview questions and answers are given below. ","result":"The following are common C++ interview questions and corresponding responses that are frequently asked during interviews."},{"tag":"p","original":" C++ is an object-oriented programming language created by Bjarne Stroustrup. It was released in 1985. ","result":"C++ is a programming language developed by Bjarne Stroustrup that incorporates the principles of object-oriented programming. Its first version was released in the year 1985."},{"tag":"p","original":" C++ is a superset of C with the major addition of classes in C language. ","result":"C++ expands upon the C language by adding the feature of classes, making it a more comprehensive language."},{"tag":"p","original":" Initially, Stroustrup called the new language \"C with classes\". However, after sometime the name was changed to C++. The idea of C++ comes from the C increment operator ++.  ","result":"The initial name given to the new programming language developed by Bjarne Stroustrup was \"C with classes\". However, the name was eventually changed to C++ which was inspired by the C increment operator, ++."},{"tag":"p","original":" C++ doesn't only maintains all aspects from C language, it also simplifies memory management and adds several features like: ","result":"C++ has inherited all the features of the C language while improving memory management and introducing new features. Some of these features include:"},{"tag":"li","original":" C++ is a highly portable language means that the software developed using C++ language can run on any platform. ","result":"One of the benefits of using C++ as a programming language is its high portability, meaning that any software created using C++ can easily function on multiple platforms without any modification."},{"tag":"li","original":" C++ is an object-oriented programming language which includes the concepts such as classes, objects, inheritance, polymorphism, abstraction. ","result":"C++ is a coding language that operates on an object-oriented paradigm. It comprises the building blocks of object-oriented programming such as classes, objects, inheritance, polymorphism, and abstraction."},{"tag":"li","original":" C++ has the concept of inheritance. Through inheritance, one can eliminate the redundant code and can reuse the existing classes. ","result":"The programming language C++ offers the feature of inheritance which allows for the elimination of duplicated code, and enables the reusability of pre-existing classes."},{"tag":"li","original":" Data hiding helps the programmer to build secure programs so that the program cannot be attacked by the invaders. ","result":"Programmers use data hiding to develop secure programs that protect against potential attacks by unauthorized individuals."},{"tag":"li","original":" Message passing is a technique used for communication between the objects. ","result":"One common way for objects to communicate with each other is through a method called message passing."},{"tag":"li","original":" C++ contains a rich function library. ","result":"The function library in C++ is extensive and comprehensive."},{"tag":"p","original":" Following are the differences between C and C++: ","result":"The distinctions between C and C++ can be described as follows:"},{"tag":"td","original":" C language was developed by Dennis Ritchie. ","result":"Dennis Ritchie is the individual credited with creating the C language."},{"tag":"td","original":" C++ language was developed by Bjarne Stroustrup. ","result":"Bjarne Stroustrup is attributed to the creation of the C++ language."},{"tag":"td","original":" C is a structured programming language. ","result":"C is a coding language that follows a structured programming approach."},{"tag":"td","original":" C++ supports both structural and object-oriented programming language. ","result":"C++ has the capability to support both structural and object-oriented programming paradigms."},{"tag":"td","original":" C is a subset of C++. ","result":"The programming language C++ includes all elements of the programming language C."},{"tag":"td","original":" C++ is a superset of C.  ","result":"C++ is a programming language that builds upon the structure and syntax of C, making it a superset of the C language."},{"tag":"td","original":" In C language, data and functions are the free entities. ","result":"Data and functions are considered independent entities in the C programming language."},{"tag":"td","original":" In the C++ language, both data and functions are encapsulated together in the form of a project. ","result":"In C++, a project encapsulates both data and functions in a single entity."},{"tag":"td","original":" C does not support the data hiding. Therefore, the data can be used by the outside world. ","result":"In C programming language, there is no support for the concept of data hiding. Hence, it allows the external world to access the data."},{"tag":"td","original":" C++ supports data hiding. Therefore, the data cannot be accessed by the outside world. ","result":"C++ has the ability to provide data hiding, which means that the data cannot be accessed by external entities or in other words, by anyone outside of the class."},{"tag":"td","original":" C supports neither function nor operator overloading. ","result":"The C programming language does not allow for either function or operator overloading."},{"tag":"td","original":" C++ supports both function and operator overloading.  ","result":"In the C++ programming language, it is possible to perform both function and operator overloading. This feature allows for multiple functions or operators to have the same name but different parameters or behaviors."},{"tag":"td","original":" In C, the function cannot be implemented inside the structures. ","result":"It is not possible to implement the function inside the structures when programming in the C language."},{"tag":"td","original":" In the C++, the function can be implemented inside the structures. ","result":"C++ allows functions to be defined inside structures."},{"tag":"td","original":" Reference variables are not supported in C language. ","result":"In the C programming language, you cannot work with reference variables as they are not supported."},{"tag":"td","original":" C++ supports the reference variables. ","result":"C++ allows for the use of reference variables in its code."},{"tag":"td","original":" C language does not support the virtual and friend functions. ","result":"The C programming language does not possess the capability to incorporate virtual and friend functions."},{"tag":"td","original":" C++ supports both virtual and friend functions. ","result":"The C++ programming language has the capabilities to handle both virtual and friend functions."},{"tag":"td","original":" In C, scanf() and printf() are mainly used for input/output. ","result":"The functions scanf() and printf() are commonly utilized in C programming for input and output tasks."},{"tag":"td","original":" C++ mainly uses stream cin and cout to perform input and output operations. ","result":"The primary method for performing input and output operations in C++ is through the use of stream objects, namely cin and cout."},{"tag":"p","original":" Following are the differences between reference and pointer: ","result":"The following points highlight the distinctions between reference and pointer:"},{"tag":"td","original":" Reference behaves like an alias for an existing variable, i.e., it is a temporary variable.  ","result":"A reference is a temporary variable that functions as an alias for an already existing variable."},{"tag":"td","original":" The pointer is a variable which stores the address of a variable. ","result":"A pointer is a type of variable that stores the memory address of another variable."},{"tag":"td","original":" Reference variable does not require any indirection operator to access the value. A reference variable can be used directly to access the value. ","result":"A reference variable is a type of variable that allows direct access to its value without the use of any indirection operator. This means that the value can be accessed directly through the reference variable, without the need for any extra steps."},{"tag":"td","original":" Pointer variable requires an indirection operator to access the value of a variable. ","result":"To access the value of a variable using a pointer variable, one must use an indirection operator."},{"tag":"td","original":" Once the reference variable is assigned, then it cannot be reassigned with different address values. ","result":"Once a reference variable is linked with a particular memory address, it cannot be relinked with a different address value."},{"tag":"td","original":" The pointer variable is an independent variable means that it can be reassigned to point to different objects. ","result":"The pointer variable has the ability to be re-pointed to other objects, which makes it an independent variable."},{"tag":"td","original":" A null value cannot be assigned to the reference variable. ","result":"It is impossible to assign a null value to a reference variable."},{"tag":"td","original":" A null value can be assigned to the reference variable. ","result":"The reference variable is capable of being assigned a null value."},{"tag":"td","original":" It is necessary to initialize the variable at the time of declaration. ","result":"When declaring a variable, it is important to give it an initial value or assign it a value before using it in the program."},{"tag":"td","original":" It is not necessary to initialize the variable at the time of declaration. ","result":"When declaring a variable, initializing it is an optional step and not mandatory to be done simultaneously with the declaration."},{"tag":"p","original":" The class is a user-defined data type. The class is declared with the keyword class. The class contains the data members, and member functions whose access is defined by the three modifiers are private, public and protected. The class defines the type definition of the category of things. It defines a datatype, but it does not define the data it just specifies the structure of data. ","result":"A class is a category of user-defined data type declared with the keyword 'class'. It consists of data members and member functions, with access defined by the modifiers private, public and protected. Essentially, a class defines a particular category or type definition for things, indicating their structure and attributes without specifying actual data values."},{"tag":"p","original":" You can create N number of objects from a class. ","result":"It is possible to generate multiple instances of a class, meaning that you can create numerous objects from a single class."},{"tag":"p","original":" The various OOPS concepts in C++ are: ","result":"C++ has several OOPS concepts, including encapsulation, inheritance, polymorphism, and abstraction."},{"tag":"p","original":" The class is a user-defined data type which defines its properties and its functions. For example, Human being is a class. The body parts of a human being are its properties, and the actions performed by the body parts are known as functions. The class does not occupy any memory space. Therefore, we can say that the class is the only logical representation of the data. ","result":"A class is a type of data that is defined by the user. It includes both properties and functions, such as in the case of a human being, where body parts are the properties and actions performed by the body parts are the functions. Classes do not take up any memory space, and are a logical representation of data."},{"tag":"strong","original":" The syntax of declaring the class: ","result":"Sure, here's a rephrased version:\n\nYou can declare a class using a specific syntax. This involves defining the class name and its properties and methods. The structure of a class can vary depending on the programming language being used."},{"tag":"p","original":" An object is a run-time entity. An object is the instance of the class. An object can represent a person, place or any other item. An object can operate on both data members and member functions. The class does not occupy any memory space. When an object is created using a new keyword, then space is allocated for the variable in a heap, and the starting address is stored in the stack memory. When an object is created without a new keyword, then space is not allocated in the heap memory, and the object contains the null value in the stack. ","result":"In programming, an object is a dynamic entity that represents an instance of a class. It can represent any item, person, or place and can operate on both data members and member functions. It's important to note that the class itself does not occupy any memory space. When an object is created using the \"new\" keyword, space is allocated in the program's heap memory. The starting address of the variable is then stored in the stack memory. If an object is created without the \"new\" keyword, space isn't allocated in the heap memory. As a result, the object contains a null value in the stack."},{"tag":"p","original":"  The syntax for declaring the object","result":"Here's a possible rephrased version of the content:\n\nTo declare an object in Java, you need to use a specific syntax. This syntax involves specifying the object's type, followed by the object's name, and then using the \"new\" keyword to create the object. For example, if you wanted to declare an object that represents a car, you could use the following code:\n\nCar myCar = new Car(); \n\nThis code creates a new object of type \"Car\" and assigns it to the variable \"myCar\". You can then use this object to perform various operations, depending on what functionality the Car class has defined."},{"tag":"p","original":" Inheritance provides reusability. Reusability means that one can use the functionalities of the existing class. It eliminates the redundancy of code. Inheritance is a technique of deriving a new class from the old class. The old class is known as the base class, and the new class is known as derived class.  ","result":"In software development, inheritance is a powerful concept that enables programmers to reuse existing code and eliminate redundancy. With inheritance, a new class can be created by deriving from an existing, or base, class. The resulting class is known as a derived class. This approach allows developers to build upon the functionality of an existing class and leverage its capabilities in new and unique ways. Ultimately, inheritance offers a means of achieving greater efficiency and productivity in software development."},{"tag":"p","original":" Encapsulation is a technique of wrapping the data members and member functions in a single unit. It binds the data within a class, and no outside method can access the data. If the data member is private, then the member function can only access the data. ","result":"Encapsulation refers to the process of grouping together data members and member functions within a class. This approach essentially restricts external methods from accessing the data within the class, except for the member functions that are specifically implemented for that purpose. The data is thus kept secure, and the code remains easier to manage."},{"tag":"p","original":" Abstraction is a technique of showing only essential details without representing the implementation details. If the members are defined with a public keyword, then the members are accessible outside also. If the members are defined with a private keyword, then the members are not accessible by the outside methods. ","result":"Abstraction is a method used to display only necessary information without revealing implementation details. If the members are described as public, then they can be accessed outside the scope. However, if they are declared as private, external methods cannot access them."},{"tag":"p","original":" Data binding is a process of binding the application UI and business logic. Any change made in the business logic will reflect directly to the application UI. ","result":"Data binding is a crucial process that connects the user interface of an application with its underlying business logic. It facilitates easy synchronization between the two, so that any changes that are made to the business logic will automatically be reflected in the application's user interface, thus ensuring a seamless and efficient user experience."},{"tag":"p","original":" Polymorphism means multiple forms. Polymorphism means having more than one function with the same name but with different functionalities. Polymorphism is of two types: ","result":"Polymorphism is a concept that refers to the presence of various forms. In programming, it is achieved by having multiple functions with the same name but distinct functionalities. There are two types of polymorphism."},{"tag":"li","original":" Static polymorphism is also known as early binding. ","result":"The term \"static polymorphism\" is synonymous with \"early binding.\""},{"tag":"li","original":" Dynamic polymorphism is also known as late binding. ","result":"Late binding is another term used for dynamic polymorphism."},{"tag":"p","original":" Polymorphism: Polymorphism means multiple forms. It means having more than one function with the same function name but with different functionalities. ","result":"Polymorphism is a concept that involves having multiple forms or variations of something. In programming, polymorphism refers to the ability to use the same function name for two or more functions that have different functionalities."},{"tag":"strong","original":" Polymorphism is of two types: ","result":"Polymorphism can be classified into two types."},{"tag":"p","original":" Runtime polymorphism is also known as dynamic polymorphism. Function overriding is an example of runtime polymorphism. Function overriding means when the child class contains the method which is already present in the parent class. Hence, the child class overrides the method of the parent class. In case of function overriding, parent and child class both contains the same function with the different definition. The call to the function is determined at runtime is known as runtime polymorphism. ","result":"Runtime polymorphism, also called dynamic polymorphism, is a type of polymorphism where method calls are resolved at runtime. An example of runtime polymorphism is function overriding, which occurs when a child class has a method that is already present in its parent class. In such cases, the child class method overrides the parent class method, with different definitions of the same function present in both classes. Since the function called is determined at runtime, this is an example of runtime polymorphism."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Let me explain this using an example:"},{"tag":"p","original":" Compile-time polymorphism is also known as static polymorphism. The polymorphism which is implemented at the compile time is known as compile-time polymorphism. Method overloading is an example of compile-time polymorphism. ","result":"Compile-time polymorphism, which is also referred to as static polymorphism, is a type of polymorphism that occurs during the compilation of code. This means that the specific polymorphic behavior of code is determined and resolved at the time the code is compiled. An example of compile-time polymorphism is method overloading."},{"tag":"p","original":"  Method overloading:  Method overloading is a technique which allows you to have more than one function with the same function name but with different functionality. ","result":"Method overloading is a programming technique that enables the creation of multiple functions with the same name, but each with unique functionality. This technique is useful for improving code readability and organization."},{"tag":"p","original":" Method overloading can be possible on the following basis: ","result":"It is possible to achieve method overloading by following certain criteria."},{"tag":"li","original":" The return type of the overloaded function. ","result":"Reworded: The type of value that the function returns after it has been overloaded."},{"tag":"li","original":" The type of the parameters passed to the function. ","result":"This statement is referring to the data types of the arguments that are provided to a function."},{"tag":"li","original":" The number of parameters passed to the function. ","result":"Reword the statement to avoid copying the original text: \n\nDescribe the total count of arguments that are supplied to the function."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Let me provide an example to help illustrate this concept:"},{"tag":"li","original":" In the above example, mul() is an overloaded function with the different number of parameters. ","result":"The example provided showcases the use of an overloaded function named mul() that can take different numbers of parameters."},{"tag":"li","original":" The namespace is a logical division of the code which is designed to stop the naming conflict.  ","result":"The namespace is a method of organizing code to avoid naming conflicts and ensure logical division within the code."},{"tag":"li","original":" The namespace defines the scope where the identifiers such as variables, class, functions are declared. ","result":"The namespace establishes the domain where the different unique identifiers like functions, classes, and variables are defined."},{"tag":"li","original":" The main purpose of using namespace in C++ is to remove the ambiguity. Ambiquity occurs when the different task occurs with the same name. ","result":"The use of namespaces in C++ aims to prevent ambiguity from arising. Ambiguity typically occurs when different operations utilize the same name."},{"tag":"li","original":" For example: if there are two functions exist with the same name such as add(). In order to prevent this ambiguity, the namespace is used. Functions are declared in different namespaces. ","result":"Code ambiguity can occur when there are two or more functions with the same name. This issue can be resolved using namespaces. By declaring functions in different namespaces, they can be uniquely identified and called without confusion or duplication."},{"tag":"li","original":" C++ consists of a standard namespace, i.e., std which contains inbuilt classes and functions. So, by using the statement \"using namespace std;\" includes the namespace \"std\" in our program. ","result":"C++ has a standard namespace called std, which comprises of built-in classes and functions. To use this namespace in a program, we can include it by adding the statement \"using namespace std;\"."},{"tag":"p","original":" Syntax of accessing the namespace variable: ","result":"Reworded: \"The structure for accessing the variable contained within a namespace:\""},{"tag":"strong","original":" Let's understand this through an example: ","result":"Allow me to provide an example to help clarify this concept:"},{"tag":"p","original":" A token in C++ can be a keyword, identifier, literal, constant and symbol. ","result":"In C++, tokens encompass keywords, identifiers, literals, constants, and symbols. These elements make up the building blocks of the language's syntax."},{"tag":"p","original":" Following are the operations that can be performed on pointers: ","result":"The following are the available tasks that can be executed by pointers:"},{"tag":"strong","original":" Incrementing or decrementing a pointer ","result":"Rewritten: Modifying the value stored in a pointer by either increasing or decreasing it."},{"tag":"strong","original":" There are two types of increment pointers: ","result":"Increment pointers can be categorized into two types."},{"tag":"p","original":"  1. Pre-increment pointer : The pre-increment operator increments the operand by 1, and the value of the expression becomes the resulting value of the incremented. Suppose ptr is a pointer then pre-increment pointer is represented as ++ptr. ","result":"The pre-increment pointer operator is used to increase the value of the operand by 1 and set the resulting value as the value of the expression. If ptr is a pointer, then we represent pre-increment pointer as ++ptr."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Let me provide an illustration to explain this further:"},{"tag":"p","original":"  2. Post-increment pointer : The post-increment operator increments the operand by 1, but the value of the expression will be the value of the operand prior to the incremented value of the operand. Suppose ptr is a pointer then post-increment pointer is represented as ptr++. ","result":"The post-increment operator is used to increase the value of an operand by 1, but the resulting value of the expression is based on the original value of the operand prior to being increased. In the context of a pointer named \"ptr\", the post-increment pointer is represented as \"ptr++\"."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Here's a possible rephrased version:\n\nTo illustrate the concept, consider the following example:"},{"tag":"strong","original":" Subtracting a pointer from another pointer: ","result":"The act of subtracting one pointer from another pointer."},{"tag":"p","original":" Std is the default namespace standard used in C++. ","result":"In C++, the usual namespace convention is to use \"std\" as the default namespace standard."},{"tag":"p","original":" C++was discovered in order to cope with the disadvantages of C. ","result":"C++ was created as a solution to address the limitations of the C programming language."},{"tag":"p","original":" Delete is used to release a unit of memory, delete[] is used to release an array. ","result":"The two different types of memory release in C++ are delete and delete[]. Delete is used to free up a single unit of memory, whereas delete[] is used to free up memory allocated for an array."},{"tag":"p","original":" STL stands for Standard Template Library. ","result":"STL is an abbreviation for Standard Template Library."},{"tag":"p","original":" The Object is the instance of a class. A class provides a blueprint for objects. So you can create an object from a class. The objects of a class are declared with the same sort of declaration that we declare variables of basic types. ","result":"An object is a specific instance of a class, which defines its properties and behaviors. When we create a class, we are essentially providing a plan or blueprint for objects that will be created based on that class. These objects are created using the same syntax as when declaring variables of basic types."},{"tag":"p","original":" The access specifiers are used to define how to functions and variables can be accessed outside the class. ","result":"In Object-Oriented Programming, access specifiers determine the level of access to class functions and variables from outside the class. They define the visibility of the class members to other classes and programs."},{"tag":"p","original":" There are three types of access specifiers: ","result":"Access specifiers can be classified into three types."},{"tag":"p","original":" OOP is a methodology or paradigm that provides many concepts. The basic concepts of Object Oriented Programming are given below: ","result":"The fundamental principles of Object Oriented Programming (OOP) encompass various concepts and methodologies. These concepts include the core ideas that form the foundation of OOP."},{"tag":"p","original":"  Classes and Objects : Classes are used to specify the structure of the data. They define the data type. You can create any number of objects from a class. Objects are the instances of classes. ","result":"Class and object are important concepts in programming. A class is used for defining the structure or data type of information. Meanwhile, an object is an instance created from a class. It is possible to create multiple objects from a single class."},{"tag":"p","original":"  Encapsulation : Encapsulation is a mechanism which binds the data and associated operations together and thus hides the data from the outside world. Encapsulation is also known as data hiding. In C++, It is achieved using the access specifiers, i.e., public, private and protected. ","result":"Encapsulation is a technique that combines data and its related functions together, providing them with a protective covering and thereby concealing them from outside access. This concept is also referred to as data hiding. In C++, access specifiers such as public, private and protected are used to achieve encapsulation."},{"tag":"p","original":"  Abstraction : Abstraction is used to hide the internal implementations and show only the necessary details to the outer world. Data abstraction is implemented using interfaces and abstract classes in C++. ","result":"Abstraction is a technique used to conceal the inner workings of a system and expose only the essential details to external users. In C++, data abstraction is achieved through the use of abstract classes and interfaces."},{"tag":"p","original":" Some people confused about Encapsulation and abstraction, but they both are different. ","result":"Encapsulation and abstraction are commonly confused terms although they have distinct meanings."},{"tag":"p","original":"  Inheritance : Inheritance is used to inherit the property of one class into another class. It facilitates you to define one class in term of another class. ","result":"Inheritance is a programming concept that allows one class to inherit the properties and methods of another class. It enables the creation of classes based on other classes, making it possible to define new classes in terms of existing ones. By using inheritance, you can extend the functionality of a class without having to redefine it from scratch."},{"tag":"li","original":" An Array is a collection of homogeneous elements while a list is a collection of heterogeneous elements. ","result":"An array is made up of elements that are of the same type, while a list consists of elements that can be of different types."},{"tag":"li","original":" Array memory allocation is static and continuous while List memory allocation is dynamic and random. ","result":"The allocation of memory for arrays is fixed and contiguous, whereas the allocation of memory for lists is flexible and non-sequential."},{"tag":"li","original":" In Array, users don't need to keep in track of next memory allocation while In the list, the user has to keep in track of next location where memory is allocated. ","result":"The key difference between Arrays and Lists lies in the management of memory allocation. Arrays automate the process of memory allocation while Lists require the user to manually keep track of the next location in memory where data should be allocated."},{"tag":"li","original":" new() is a preprocessor while malloc() is a function. ","result":"The function new() and the function malloc() have different natures - new() is classified as a preprocessor while malloc() is a regular function."},{"tag":"li","original":" There is no need to allocate the memory while using \"new\" but in malloc() you have to use sizeof(). ","result":"Allocating memory can be done using \"new\" or malloc(). However, it's worth noting that while using \"new\", memory doesn't need to be explicitly allocated, whereas with malloc(), you need to include sizeof()."},{"tag":"li","original":" \"new\" initializes the new memory to 0 while malloc() gives random value in the newly allotted memory location. ","result":"The \"new\" keyword sets the newly allocated memory to zero, whereas the malloc() function assigns a random value to the newly allocated memory location."},{"tag":"li","original":" The new() operator allocates the memory and calls the constructor for the object initialization and malloc() function allocates the memory but does not call the constructor for the object initialization. ","result":"The difference between the new() operator and malloc() function lies in the fact that new() allocates memory and calls the constructor for object initialization, whereas malloc() only allocates memory without initializing the object's constructor."},{"tag":"li","original":" The new() operator is faster than the malloc() function as operator is faster than the function. ","result":"The performance of the new() operator is superior to that of the malloc() function because operators are generally faster than functions."},{"tag":"p","original":" There are two ways: ","result":"There are a couple of methods to achieve this goal:"},{"tag":"li","original":" By using the DLL's type library. ","result":"One can access the functions and interfaces provided by a DLL by utilizing its type library."},{"tag":"li","original":" Taking a reference to the function from the DLL instance. ","result":"One way to access a function from a DLL is to reference the function within the DLL instance."},{"tag":"p","original":" Friend function acts as a friend of the class. It can access the private and protected members of the class. The friend function is not a member of the class, but it must be listed in the class definition. The non-member function cannot access the private data of the class. Sometimes, it is necessary for the non-member function to access the data. The friend function is a non-member function and has the ability to access the private data of the class. ","result":"A friend function is an external function that is given access to the private and protected members of a class. Although it is not a member of the class, it must be declared within the class definition to be recognized as a friend. Since non-member functions cannot access a class's private data, a friend function is useful when it needs access to such data. With this capability, the friend function can manipulate the class's private data without violating the rules of encapsulation."},{"tag":"strong","original":" To make an outside function friendly to the class, we need to declare the function as a friend of the class as shown below: ","result":"In order to allow an external function to access the private members of a class, it can be declared as a friend of the class."},{"tag":"strong","original":" Following are the characteristics of a friend function: ","result":"The following are the defining traits of a friend function:"},{"tag":"li","original":" The friend function is not in the scope of the class in which it has been declared. ","result":"The scope of the friend function is outside the class where it has been defined."},{"tag":"li","original":" Since it is not in the scope of the class, so it cannot be called by using the object of the class. Therefore, friend function can be invoked like a normal function. ","result":"The friend function is not accessible through the object of the class as it falls outside the scope of the class. As a result, it can be called just like any other regular function."},{"tag":"li","original":" A friend function cannot access the private members directly, it has to use an object name and dot operator with each member name. ","result":"When implementing a friend function, it is not possible to access private members directly. Instead, it is necessary to use the object name and dot operator to access each member individually."},{"tag":"li","original":" Friend function uses objects as arguments. ","result":"A friend function receives objects as arguments."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Allow me to demonstrate using an illustration:"},{"tag":"li","original":" A virtual function is used to replace the implementation provided by the base class. The replacement is always called whenever the object in question is actually of the derived class, even if the object is accessed by a base pointer rather than a derived pointer. ","result":"A virtual function is utilized to override the implementation provided by the superclass. Whenever an object is of the subclass, the overridden function is called regardless of whether the object is accessed with a base pointer or a subclass pointer."},{"tag":"li","original":" A virtual function is a member function which is present in the base class and redefined by the derived class. ","result":"A virtual function is a type of member function that can be defined in a base class and later redefined in a derived class."},{"tag":"li","original":" When we use the same function name in both base and derived class, the function in base class is declared with a keyword virtual. ","result":"In cases where a function has the same name in a base and derived class, it is essential to declare the function in the base class with the virtual keyword. This allows the correct function to be called at runtime."},{"tag":"li","original":" When the function is made virtual, then C++ determines at run-time which function is to be called based on the type of the object pointed by the base class pointer. Thus, by making the base class pointer to point different objects, we can execute different versions of the virtual functions. ","result":"In C++, when a function is declared as virtual, the program determines which version of the function to call at run-time based on the object type that the base class pointer is pointing to. This means that by using a base class pointer to point to different objects, we can call and execute different variations of the virtual functions."},{"tag":"strong","original":" Rules of a virtual function: ","result":"When defining a virtual function in a class, specific rules must be followed. These rules dictate the behavior and implementation of the virtual function within the class and ensure proper usage of the function."},{"tag":"li","original":" The virtual functions should be a member of some class. ","result":"It is necessary for virtual functions to belong to a particular class."},{"tag":"li","original":" The virtual function cannot be a static member. ","result":"It is not possible to declare a virtual function as a static member."},{"tag":"li","original":" Virtual functions are called by using the object pointer. ","result":"To invoke virtual functions, one must utilize the object pointer."},{"tag":"li","original":" It can be a friend of another class. ","result":"It is possible for a student to have a friend who belongs to a different class."},{"tag":"li","original":" C++ does not contain virtual constructors but can have a virtual destructor. ","result":"In C++, virtual constructors are not supported, although a virtual destructor can be utilized."},{"tag":"p","original":" You can answer this question in three manners: ","result":"There are three ways to approach answering this question."},{"tag":"li","original":" If you find that the problem domain cannot be accurately modeled any other way. ","result":"If it is not possible to model the problem domain accurately through any other means, then it may be necessary to resort to using a particular approach."},{"tag":"p","original":" A Destructor is used to delete any extra resources allocated by the object. A destructor function is called automatically once the object goes out of the scope. ","result":"A destructor is a function that is employed to free any additional resources that were allocated by the object during its initialization. The destructor function is called automatically when the object is no longer in use or goes out of the scope."},{"tag":"li","original":" Destructors have the same name as class name and it is preceded by tilde. ","result":"The destructor in C++ bears the same name as the class it belongs to and is identifiable by the tilde symbol that precedes it."},{"tag":"li","original":" It does not contain any argument and no return type. ","result":"The statement lacks both an argument and a return type."},{"tag":"p","original":" It is a type of arithmetical error. It happens when the result of an arithmetical operation been greater than the actual space provided by the system. ","result":"Arithmetic overflow occurs when the computed result of a mathematical operation exceeds the allocated memory space of the system. It is a type of mathematical error that can result in inaccurate or missing data."},{"tag":"li","original":" When a single object behaves in many ways is known as overloading. A single object has the same name, but it provides different versions of the same function. ","result":"Overloading refers to the occurrence when a particular object shows various behaviors. This means that even though a specific object has a singular name, it can provide various versions of a function with different behaviors."},{"tag":"li","original":" C++ facilitates you to specify more than one definition for a function name or an operator in the same scope. It is called function overloading and operator overloading respectively. ","result":"In C++, it's possible to define multiple definitions for a function or operator within the same scope, a feature commonly referred to as function overloading and operator overloading respectively."},{"tag":"strong","original":" Overloading is of two types: ","result":"There are two different types of overloading."},{"tag":"p","original":"  1. Operator overloading:  Operator overloading is a compile-time polymorphism in which a standard operator is overloaded to provide a user-defined definition to it. For example, '+' operator is overloaded to perform the addition operation on data types such as int, float, etc. ","result":"Operator overloading is a programming technique that allows the user to define their own meaning for a standard operator. This method of polymorphism occurs during the compilation of code and enables the user to customize the behavior of operators such as '+', '*', etc., for different data types. In simpler terms, operator overloading lets the user redefine the operations of standard operators."},{"tag":"strong","original":" Operator overloading can be implemented in the following functions: ","result":"The following functions can be utilized to implement operator overloading."},{"tag":"strong","original":" Syntax of Operator overloading: ","result":"Sure, here's a rephrased version of the content:\n\nOperator overloading is a feature in many programming languages that allows developers to give special meaning to operators (+, -, *, /, etc.) when they are used with user-defined types, such as objects or classes. By overloading operators, developers can make their code more concise and intuitive. The syntax for operator overloading varies depending on the programming language, but it typically involves defining a special method or function for each operator that the developer wants to overload."},{"tag":"p","original":"  2. Function overloading:  Function overloading is also a type of compile-time polymorphism which can define a family of functions with the same name. The function would perform different operations based on the argument list in the function call. The function to be invoked depends on the number of arguments and the type of the arguments in the argument list. ","result":"Compile-time polymorphism refers to the use of inheritance and function overloading to create multiple functions with the same name. Inheritance allows the creation of new objects based on existing ones, while function overloading enables multiple functions with different argument lists to have the same name. This allows for different functions to be called based on the number and type of arguments in the function call."},{"tag":"p","original":" If you inherit a class into a derived class and provide a definition for one of the base class's function again inside the derived class, then this function is called overridden function, and this mechanism is known as function overriding. ","result":"When you extend a class in a sub-class and give a different definition to one of the functions from the parent class, it's referred to as \"overriding\". This means that the sub-class will use its own version of the function instead of the one from the parent class."},{"tag":"p","original":" Virtual inheritance facilitates you to create only one copy of each object even if the object appears more than one in the hierarchy. ","result":"Virtual inheritance allows you to avoid creating duplicate objects within a class hierarchy by only creating a single instance of each object, even if it appears more than once in the hierarchy."},{"tag":"p","original":" A Constructor is a special method that initializes an object. Its name must be same as class name. ","result":"A Constructor is an exceptional function used to commence an object. It is mandatory that the Constructor's name is identical to the class name."},{"tag":"p","original":" The \"delete\" operator is used to release the dynamic memory created by \"new\" operator. ","result":"The operator \"delete\" is utilized to free up the dynamic memory allocated by the \"new\" operator."},{"tag":"p","original":" This pointer holds the address of the current object. ","result":"The \"this\" pointer refers to the memory address of the current object."},{"tag":"p","original":" A scope resolution operator(::) is used to define the member function outside the class. ","result":"The double colon (::) is utilized to specify the definition of a member function outside its class definition."},{"tag":"p","original":" Delete [] is used to release the array of allocated memory which was allocated using new[] whereas delete is used to release one chunk of memory which was allocated using new. ","result":"The action of using delete [] is intended to free up an array of memory that was previously allocated with new[], while delete is used to free up a single block of memory that was previously allocated using new."},{"tag":"p","original":" The pure virtual function is a virtual function which does not contain any definition. The normal function is preceded with a keyword virtual. The pure virtual function ends with 0. ","result":"A pure virtual function is a type of virtual function in C++ that does not have any definition. In contrast, a standard virtual function is declared with the \"virtual\" keyword, but does contain a definition. Pure virtual functions are marked by ending with a 0."},{"tag":"strong","original":" Syntax of a pure virtual function: ","result":"A pure virtual function is a special type of function that uses the \"= 0\" syntax to indicate that it doesn't have a definition and must be overridden by any derived class."},{"tag":"strong","original":" Let's understand this through an example: ","result":"Let me provide an illustration to clarify this point:"},{"tag":"td","original":" A structure is a user-defined data type which contains variables of dissimilar data types. ","result":"A structure is a type of data structure that is created by the user and can hold variables of different data types."},{"tag":"td","original":" The class is a user-defined data type which contains member variables and member functions.  ","result":"A class is a type of data that is defined by the user and includes member functions and member variables."},{"tag":"td","original":" The variables of a structure are stored in the stack memory. ","result":"The stack memory is used to store the variables of a structure."},{"tag":"td","original":" The variables of a class are stored in the heap memory. ","result":"The attributes or properties of a class are typically stored in the heap memory of a computer system."},{"tag":"td","original":" We cannot initialize the variables directly. ","result":"It's not possible to directly assign values to the variables for initialization."},{"tag":"td","original":" We can initialize the member variables directly. ","result":"One possible way to set the values of the member variables in a class is to assign them directly during their initialization."},{"tag":"td","original":" If access specifier is not specified, then by default the access specifier of the variable is \"public\". ","result":"If a variable's access specifier is not explicitly declared, it will automatically default to \"public\"."},{"tag":"td","original":" If access specifier is not specified, then by default the access specifier of a variable is \"private\". ","result":"If an access specifier is not explicitly indicated, then the default specifier for a variable will be \"private\"."},{"tag":"td","original":" The instance of a structure is a \"structure variable\". ","result":"A structure variable can be defined as an occurrence of a structure."},{"tag":"strong","original":" Declaration of a structure: ","result":"A structure is formally defined by defining a group of variables with different data types to become a single unit."},{"tag":"td","original":" A structure is declared by using a struct keyword. ","result":"To create a structure, one must use the keyword \"struct\"."},{"tag":"td","original":" The class is declared by using a class keyword. ","result":"To declare a class, one must use the keyword \"class.\""},{"tag":"td","original":" The structure does not support the inheritance. ","result":"The structure in question is not designed to accommodate inheritance."},{"tag":"td","original":" The class supports the concept of inheritance. ","result":"The class is capable of implementing inheritance, a fundamental principle in object-oriented programming."},{"tag":"td","original":" The type of a structure is a value type. ","result":"A structure is considered a value type."},{"tag":"td","original":" The type of a class is a reference type. ","result":"A class is categorized as a reference type, indicating that it is not a primitive type and that it is a reference to values stored elsewhere in memory."},{"tag":"p","original":" A class template is used to create a family of classes and functions. For example, we can create a template of an array class which will enable us to create an array of various types such as int, float, char, etc. Similarly, we can create a template for a function, suppose we have a function add(), then we can create multiple versions of add(). ","result":"A class template is a useful tool for creating a series of related classes and functions. It enables us to create a family of classes that share the same structure and operations, allowing us to easily create objects of different types that share the same behaviors. Similarly, a function template helps us create multiple versions of the same function, allowing us to accommodate various input types seamlessly. Overall, templates are powerful tools that make object-oriented programming more flexible and efficient."},{"tag":"strong","original":" The syntax of a class template: ","result":"Here's a possible rephrased version of the content:\n\nA class template has a particular syntax that defines how it's structured. This syntax will be different from that of a non-template class because it includes placeholders for template arguments. When you create an instance of a class template, these placeholders get replaced with actual values, which allows you to generate multiple slightly different versions of the same class. Understanding the syntax of a class template is crucial for using it effectively."},{"tag":"strong","original":" Syntax of a object of a template class: ","result":"Rewording: \nThe syntax of an object belonging to a template class can be described as follows."},{"tag":"p","original":"  Function overloading:  Function overloading is defined as we can have more than one version of the same function. The versions of a function will have different signature means that they have a different set of parameters","result":"Function overloading refers to the creation of multiple variations of a function, with each variation having a different signature, i.e., a different set of parameters. Essentially, function overloading enables a programmer to create several versions of the same function to perform varying tasks."},{"tag":"p","original":"  Operator overloading:  Operator overloading is defined as the standard operator can be redefined so that it has a different meaning when applied to the instances of a class. ","result":"Operator overloading refers to the practice of redefining the standard operators in a programming language so that they perform different tasks when applied to objects of a particular class."},{"tag":"p","original":" A virtual destructor in C++ is used in the base class so that the derived class object can also be destroyed. A virtual destructor is declared by using the ~ tilde operator and then virtual keyword before the constructor. ","result":"A virtual destructor is a special type of destructor used in C++ that allows a derived class object to be properly destroyed when the base class object is deleted. To define a virtual destructor in C++, the destructor is declared using the tilde (~) operator followed by the virtual keyword before the constructor."},{"tag":"strong","original":" Let's understand this through an example ","result":"Let's take an instance to illustrate this concept."},{"tag":"li","original":" Example without using virtual destructor ","result":"An example of a class without a virtual destructor will be provided without copying any part of the original content."},{"tag":"p","original":" In the above example, delete b will only call the base class destructor due to which derived class destructor remains undestroyed. This leads to the memory leak. ","result":"When we delete an object of the derived class that has a base class, it's essential to ensure that both the base and derived class destructors get called to avoid memory leaks. However, if we only call the base class destructor, it leaves the derived class destructor undestroyed and causes memory leaks."},{"tag":"li","original":" Example with a virtual destructor ","result":"Here's an example of using a virtual destructor:\n\nConsider a class hierarchy where the derived classes add additional resources to the base class. In order to properly deallocate these resources when destroying an object of the derived class, a virtual destructor is needed. This ensures that the destructor of the derived class is called first, followed by the destructor of the base class. Without a virtual destructor, only the destructor of the base class would be called, leaving the additional resources allocated by the derived class undeallocated, leading to memory leaks. Therefore, it's crucial to always include a virtual destructor in base classes whenever the possibility of derivation exists."},{"tag":"p","original":" When we use the virtual destructor, then the derived class destructor is called first, and then the base class destructor is called. ","result":"Using a virtual destructor entails that the destructor of the derived class is invoked before that of the base class. In other words, the derived class destructor is executed first, followed by the base class destructor."},{"tag":"a","original":" Java Basics Interview Questions ","result":"Below are some commonly asked questions in Java Basics interviews. These questions serve as a way to test a candidate's understanding of basic Java programming concepts."},{"tag":"a","original":" Java OOPs Interview Questions ","result":"Could you please provide me with the original content to be rephrased?"},{"tag":"a","original":" Java String &amp; Exception Questions ","result":"The following questions pertain to Java strings and exceptions. Please answer them accordingly."},{"tag":"a","original":" Java Collection Interview Questions ","result":"The following are a set of interview questions related to Java collections that can be used during the recruitment process."},{"tag":"span","original":" SQL Server Interview Questions ","result":"Sure, here's my attempt: \n\nBelow are some sample questions that could be asked during an interview for a SQL Server position. These questions are intended to assess your knowledge and expertise in the area of SQL Server."},{"tag":"a","original":" Spring Boot Interview Questions ","result":"Rewritten: Below are some questions that may come up during an interview for a Spring Boot position."},{"tag":"a","original":" C Programming Interview Questions ","result":"The following are commonly asked questions in interviews for C programming:\n\n1. What is a pointer, and how does it work?\n2. What is the difference between an array and a pointer?\n3. Describe the purpose of #include and #define in C programming.\n4. What is the difference between a structure and a union?\n5. How does the switch statement work?\n6. What is the difference between ++i and i++?\n7. Explain the concept of recursion.\n8. How do you dynamically allocate memory in C?\n9. What is a function pointer?\n10. Describe the difference between call by value and call by reference."},{"tag":"a","original":" Data Structure Interview Questions ","result":"Can you provide some interview questions related to data structures?"},{"tag":"a","original":" Manual Testing Interview Questions ","result":"Kindly find below a list of interview questions related to manual testing that you can use as a reference for your interview preparation."}]