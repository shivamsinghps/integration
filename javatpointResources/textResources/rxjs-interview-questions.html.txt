
div => [ 
 ]
h1 => [ RxJS Interview Questions ]
p => [ Most Asked Interview Questions of RxJS and Reactive Programming. ]
h3 => [ 1) What is RxJS? / What do you understand by RxJS? ]
p => [  RxJS  is an acronym that full form is Reactive Extension for Javascript. It is a JavaScript library that uses observables to work with reactive programming and deals with asynchronous data calls, callbacks and event-based programs. RxJS has introduced the concept of "reactive programming" to the web. It implements a reactive extension for  TypeScript  and  JavaScript . ]
p => [ RxJS works as a combination of the observer pattern, iterator pattern and functional programming. ]
p => [ RxJS is a library for reactive programming using Observables to make it easier to compose asynchronous or callback-based code. It is a standalone JavaScript library that gives access to programmers to the Observable. ]
p => [ RxJS can also be used with other JavaScript libraries and frameworks. JavaScript and TypeScript well support it. ]
h3 => [ 2) What is Reactive Programming? ]
p => [ Reactive programming is a declarative programming paradigm which deals with asynchronous data streams. Glenn Wadden first developed reactive programming in 1986 as a programming language in the Supervisory Control and Data Acquisition (SCADA) industry. Event buses or typical click events are called asynchronous event streams, used in reactive programming to observe and do some side effects. Reactive programming facilitates us to create data streams of anything, not just from click and hover events. ]
h3 => [ 3) What should we know before going to learn RxJS? ]
p => [ Before learning RxJS, we must have a basic knowledge of JavaScript, JavaScript frameworks, and Angular. You can easily understand this technology if you have a basic understanding of JS.  ]
h3 => [ 4) What are the most outstanding features of RxJS?  ]
p => [ Following is the list of some most important features of RxJS that are used to handle the concept of RxJS or reactive programming: ]
strong => [ Observer ]
p => [ The Observer is an object with next(), error(), and complete() methods, which are called when we have to interact with the observable, i.e., the source interacts for an example button click, Http request, etc. ]
strong => [ Observable ]
p => [  In RxJS, an  observable  function is used to create an observer and attaches it to the source where values are expected. For example, clicks, mouse events from a DOM element or an Http request, etc. ]
strong => [ Subscription ]
p => [  The role of  subscription  comes in the scene when the observable is created. To execute the observable, we need to subscribe to it. It can also be used to cancel the execution. ]
strong => [ Operators ]
p => [ Operators are a very important part of RxJS. An operator is a pure function that takes observable input and emits the result in the output form. Input and output both are observable. ]
strong => [ Subject ]
p => [  A  subject  is observable that can multicast, i.e., talk to many observers. Suppose we have a button with an event listener. The function attached to the event using addlistener is called every time the user clicks on the button. Similar functionality goes for the subject too. ]
strong => [ Schedulers ]
p => [  A  scheduler  controls the execution of when the subscription has to start and be notified. ]
h3 => [ 5) What are the biggest advantages of Reactive Programming? ]
strong => [ Advantages of using Reactive Programming ]
li => [ Reactive programming provides a lot of operators that can simplify our work. ]
li => [ Reactive programming is very simple to compose streams of data. ]
li => [ It can be used to avoid "callback problems". ]
li => [ In Reactive programming, it is very simple to do async and threaded task. ]
li => [ It makes complex threading very easy. ]
li => [ By using Reactive programming, we can get a more cleaner and readable code base. ]
li => [ In Reactive programming, it is easy to implement back-pressure. ]
h3 => [ 6) What are the biggest advantages and disadvantages of using RxJS?  ]
h3 => [ Advantages of using RxJS ]
strong => [ Following is the list of key advantages of using RxJS: ]
li => [ RxJS can be used with other Javascript libraries and frameworks. It is supported by javascript and also with typescript. Few examples are Angular, ReactJS, Vuejs, nodejs etc. ]
li => [ RxJS is an awesome library when it comes to the handling of async tasks. RxJS uses observables to work with reactive programming that deals with asynchronous data calls, callbacks and event-based programs. ]
li => [ RxJS offers a huge collection of operators in mathematical, transformation, filtering, utility, conditional, error handling, join categories that makes life easy when used with reactive programming. ]
h3 => [ Disadvantages of using RxJS ]
strong => [ Following is the list of the biggest disadvantages of using RxJS: ]
li => [ Debugging the code with observables is a little difficult. ]
li => [ As you start to use Observables, you can end up with your full code wrapped under the observables. ]
h3 => [ 7) What is Redux? ]
p => [ Redux is an open-source JavaScript library which is used to manage the application state. It is most commonly used with libraries such as React, Angular, or RxJS for building user interfaces. Redux is inspired by Facebook's Flux architecture and also very similar to it. It was created by Dan Abramov and Andrew Clark.  ]
h3 => [ 8) What are the core principles of Redux?  ]
p => [ Redux follows the following three fundamental principles: ]
strong => [ Single source of truth: ]
strong => [ State is ready only: ]
strong => [ Changes are made with pure functions: ]
h3 => [ 9) What do you understand by RxJS Stream?  ]
p => [ An RxJS stream is a sequence of ongoing events ordered in time. In other words we can say that a stream is a sequence of data elements made available over time. A stream can be thought of as items on a conveyor belt being processed one at a time rather than in large batches. It is called stream because it acts as a data that is continuous and not really having an end, unless you explicitly define an end. ]
p => [ A stream can emit three different things: ]
li => [ a value (of some type) ]
li => [ an error ]
li => [ a "completed" signal ]
h3 => [ 10) What do you understand by the Reactive Manifesto document?  ]
p => [ A document was introduced to define the core principles of reactive programming. That document is known as the Reactive Manifesto. The Reactive Manifesto document was first released in 2013 by a group of developers led by a man called Jonas Boner. The Reactive Manifesto underpins the principles of reactive programming.  ]
h3 => [ 11) Is there any similarity between Redux and RxJS?  ]
p => [ Although Redux and RxJS are very different libraries for very different purposes, but they have some similarity also. ]
th => [ Redux ]
th => [ RxJS ]
td => [ Redux is a tool used to manage state throughout the application. It is usually used as architecture for UIs. Iyt can be used as an alternative to (half of) Angular. ]
td => [ RxJS is a reactive programming library. It is usually used as a tool to accomplish asynchronous tasks in JavaScript. Think of it as an alternative to Promises. ]
td => [ Redux uses the Reactive paradigm little bit because the Store is reactive. The Store observes actions from a distance, and changes itself. ]
td => [ RxJS also uses the Reactive paradigm, but instead of being architecture, it gives you basic building blocks, Observables, to accomplish this "observing from a distance" pattern. ]
h3 => [ 12) What is the difference between Reactive Programming and Imperative Programming? ]
p => [ In Reactive Programming, observables emit data, and send it to the subscribers. This process can be called as data being PUSHed in reactive programming. On the other hand, data is being PULLed in imperative programming, where we explicitly request data (iterating over collection, requesting data from the DB, etc). ]
h3 => [ 13) What is the difference between BehaviorSubject and Observable in RxJS? ]
p => [ The following table specifies the differences between BehaviourSubject and Observable in RxJS:  ]
th => [ Observable ]
th => [ BehaviourSubject ]
td => [ In RxJS, observable is stateless. ]
td => [ In RxJS, BehaviourSubject is stateful. ]
td => [ Observable creates copy of data. ]
td => [ BehaviourSubject shares data. ]
td => [ Observable is unidirectional in nature. ]
td => [ BehaviourSubject is bidirectional in nature. ]
h3 => [ 14) What are Operators in RxJS? What are the different types of operators used in RxJS?  ]
p => [ Operators are very important part of RxJS. An RxJS operator is a pure function that takes an observable as input and provides the output also in the form of observable. We have to use a pipe() method to work with operators. ]
p => [  Following is a list of most used  operators in RxJS : ]
a => [ Creation Operator ]
a => [ Mathematical Operator ]
a => [ Join Operator ]
a => [ Transformation Operator ]
a => [ Filtering Operator ]
a => [ Utility Operator ]
a => [ Conditional Operator ]
a => [ Multicasting Operator ]
a => [ Error handling Operator ]
p => [ Further, these operators are sub-divided in other types of operators. ]
h3 => [ 15) What is an Observable in RxJS?  ]
p => [ In RxJS, an observable is a function that is used to create an observer and attaches it to the source where values are expected from. For example, clicks, mouse events from a DOM element or an Http request, etc. afre the example of RxJS observable. Observable gives us the idea of an invokable collection of future values or events. It facilitates us to make asynchronous data streams using observable sequences or just called observables, too. ]
p => [  We have to follow the following three steps to complete the  RxJS observable : ]
li => [ Create Observable ]
li => [ Subscribe Observable ]
li => [ Execute Observable ]
h3 => [ 16) What is the difference between RxJS Observables and Promises? ]
p => [ Following is the list of main differences between RxJS Observables and Promises: ]
th => [ RxJS Observables ]
th => [ Promises ]
td => [ Observables are used to run asynchronously, and we get the return value multiple times. ]
td => [ Promises are used to run asynchronously, and we get the return value only once. ]
td => [ Observables are lazy. ]
td => [ Promises are not lazy.  ]
td => [ Observables can be canceled. ]
td => [ Promises cannot be canceled. ]
td => [ Observables provide multiple future values. ]
td => [ Promises provide a single future value. ]
h3 => [ 17) What are the advantages of RXJS Observables over RxJS Promises? ]
p => [ In RxJS, an Observable has many advantages over Promises. The following list shows some of them: ]
li => [ An observable is like a Stream. It is used to pass zero or more events where the callback is called for each event. ]
li => [ Observable is always preferred over Promise because it provides all the features of Promise and more. ]
li => [ By using an observable, we can handle single or multiple events. ]
li => [ Observables are cancelable, so this is also an advantage over Promises. ]
li => [ Observable allows lazy initialization. ]
li => [ Observable allows formatting data. ]
li => [ Observable provides operators like map, forEach, reduce etc. ]
h3 => [ 18) What is the difference between React and RxJS? ]
p => [ React is an open-source JavaScript library that is used to provide a view for data rendered as hypertext markup language. On the other hand, RxJS stands for Reactive Extensions for JavaScript. It is considered a library for composing asynchronous programming in web development and event-based programs using observable sequences and LINQ-style query operators. Let's see the key differences between them. ]
strong => [ Difference between React and RxJS ]
th => [ React ]
th => [ RxJS ]
td => [ React is an open-source JavaScript library. ]
td => [ RxJS is a library for composing asynchronous programming.  ]
td => [ By using React, we can easily create interactive UIs. ]
td => [ By using React, we can easily create/compose asynchronous or callback-based code. ]
h3 => [ 19) What do you understand by the term Non-Blocking in RxJS?  ]
p => [ In RxJS or Reactive programming, an algorithm is called non-blocking if threads competing for a resource do not have their execution indefinitely postponed by mutual exclusion protecting that resource. ]
p => [ This concept is used in an API that allows access to the resource if available; otherwise, it immediately returns informing the caller that the resource is not currently available or the operation has been initiated and not yet completed. A non-blocking API to a resource allows the caller to do other work rather than be blocked waiting on the resource to become available. This may be complemented by allowing the client to register for getting notified when the resource is available or the operation has been completed. ]
h3 => [ 20) What does Asynchronous means in the context of RxJS or Reactive programming?  ]
p => [ According to the Oxford Dictionary, the term asynchronous can be defined as "not existing or occurring at the same time." In the context of Reactive programming, it means that the processing of a request occurs at an arbitrary point in time, sometime after it has been transmitted from client to service. The client cannot directly observe, or synchronize with, the execution that occurs within the service. Asynchronous is the antonym of synchronous processing, which implies that the client only resumes its execution once the service has processed the request.  ]
h3 => [ 21) What is the difference between Cold and Hot Observables in RxJS?  ]
p => [ In simple words, the concept of cold and hot Observable can be defined as the following: ]
p => [ When the data is produced by the Observable itself, t is called the cold Observable. When the data is produced outside the Observable, it is called hot Observable. ]
p => [ Let's see the differences between Cold Observables and Hot Observables: ]
th => [ Cold Observables ]
th => [ Hot Observables ]
td => [ We can call an Observable "cold" when the data is produced inside the Observable. ]
td => [ We call the Observable "hot" when the data is produced outside the Observable. ]
td => [ Cold observables start to run upon subscription. ]
td => [ Hot observables produce values even before a subscription is made. ]
td => [ The Cold observable sequence only starts pushing values to observers when subscribe is called. ]
td => [ Hot observables such as mouse move events, stock pickers or WebSocket connections are already produced in values even before the subscription is active. ]
td => [ The cold Observable starts running upon subscription. ]
td => [ The hot Observable produces values before subscriptions. ]
td => [ The cold Observable sequence starts pushing values. ]
td => [ In cold Observable, the data producer is outside the Observable. ]
td => [ In cold Observable, the data is produced inside the Observable so, we cannot share the data between multiple subscribers. Two Observables that subscribe at more or less the same may receive two different values. We call this behavior "unicasting." ]
td => [ As we know that the data is produced outside the Observable in hot Observable, so it can share data between multiple subscribers in hot Observable. This behavior is "multicasting." ]
h3 => [ 22) What do you understand by the Actor Model in RxJS? ]
p => [ An actor model can do the following things: ]
li => [ An Actor model specifies that your concurrency primitives are actors. ]
li => [ It can send messages to any actors they know about. ]
li => [ It can receive a message and decide what to do next depending on the content of the message. ]
li => [ It can create new actors and provides certain guarantees, such as any actor will only handle a single message at a time and messages sent by actor X to actor Y will arrive in the order they were sent. ]
h3 => [ 23) What does a subject do in RxJS?  ]
p => [ RxJS subject is a special type of observable that allows values to be multicast to many observers. RxJS subjects are multicast instead of plain observables, which are unicast. The subject is the equivalent of an event emitter and the only way of multicast in a value or event to multiple observers. Subject implements both observable and observer interfaces. Every subject is observable so that you can subscribe to it. Every subject is an observer. It means that you have next, error, and complete methods, so you can send values, error subject or completed. ]
strong => [ Types of Subjects ]
li => [ Subject ]
li => [ ReplaySubject ]
li => [ BehaviorSubject ]
li => [ AsyncSubject ]
h3 => [ 24) What are the differences between Subject, BehaviorSubject and ReplaySubject in RxJS?  ]
h3 => [ Subject ]
p => [ In the RxJS Subject, Observers who are subscribed later do not obtain the data values emitted before their subscription. ]
h3 => [ ReplaySubject ]
p => [ In RxJS ReplaySubject, Observers who are subscribed at a later point receives data values issued before their subscription. It operates by using a buffer that holds the values emitted and re-emits them once new Observers are subscribed. ]
h3 => [ BehaviorSubject ]
p => [ BehaviorSubject functions similar to ReplaySubject but only re-issues the last emitted values. So, it should be used when you are interested in the observer's last/current value. ]
h3 => [ 25) What is RxJS Map, and what do you understand by Higher-Order Observable Mapping?  ]
p => [ RxJS map operator facilitates us to project the payload of the Observable into something else. We can see the powerful features of Observables when we start using Rx operators to transform, combine, manipulate, and work with sequences of items emitted by Observables. ]
h3 => [ RxJS Higher-Order Observable Mapping ]
p => [ We map source observable emitted value into other Observable in higher-order mapping instead of mapping a flat value like 1 to another value like 10.! The result is an Observable higher order. ]
h3 => [ 26) When should we use the switchMap, mergeMap and concatMap in RxJS? ]
p => [ There are mainly four types of mapping operators used in RxJS: concatMap(), mergeMap(), switchMap() and exhaustMap(). All of these operators are mapping or flattening operators used to flatten observables, but they are applicable in very different scenarios. The switchMap and mergeMap are the most powerful and frequently used operators. Let's see when we use these operators: ]
h3 => [ concatMap() Operators ]
p => [ Following is the sample code of concatMap() Operators: ]
p => [ The two main benefits of using concatMap() operator are that we no longer have to use nested subscribes with higher-order mapping operator, and the second is, all http requests are sent to the backend sequentially. ]
p => [ This is how the concatMap operator ensures that the requests still occur in sequence: ]
li => [ concatMap takes each form value and transforms it into an observer HTTP, known as an inner observer. ]
li => [ concatMap subscribes to the inner Observable and sends its output to the Observable result ]
li => [ The second form of value can come more quickly than is needed to request in the backend the previous form value. When this occurs, the new form value is not converted to an HTTP request immediately. ]
h3 => [ mergeMap() Operator ]
p => [ Unlike the RxJS concatMap operator, mergeMap() will not wait until the Observable finishes until the next Observable is subscribed. ]
strong => [ This is how the mergeMap operator works: ]
li => [ In mergeMap operator, every Observable source value is mapped in an internal Observable. ]
li => [ The inner Observable is then subscribed by mergeMap. ]
li => [ When the inner observables emit new values, the output Observable immediately reflects them. ]
li => [ In the mergeMap, unlike the concatMap operator, we do not need to wait until the previous inner observable is completed. ]
h3 => [ switchMap() Operator ]
p => [ Unlike the mergeMap operator, in the switchMap operator, we unsubscribe the previous Observable before subscribing to the new Observable if the new Observable begins to emit the values. ]
h3 => [ 27) What is Back-Pressure in Reactive Programming?  ]
p => [ According to the Wikipedia definition, Back-Pressure is resistance or force opposing the desired flow of fluid through pipes. But this definition belongs to fluid dynamics. In the context of software, the definition will be changed to flow of data within software instead of fluid through pipes. So, the definition would be- ]
blockquote => [ Back-Pressure is a resistance or force opposing the desired flow of data through software. ]
p => [ When one component is struggling to keep up, the entire system needs to respond sensibly. It is unacceptable for the component under stress to fail or to drop messages in an uncontrolled fashion. Since it is not easy to handle and can't fail, it should communicate that it is under stress to upstream components and get them to reduce the load. This back-pressure is an important feedback mechanism that facilitates systems to respond to load rather than collapse under such a situation gracefully. The back-pressure may cascade up to the user, at which point responsiveness may degrade. Still, this mechanism will ensure that the system is resilient under load and will provide information that may allow the system to apply other resources to make easy the load by distributing it. ]
p => [ In simple words, we can say that Back-pressure provides the strategies for coping with Observables that produce items more rapidly than their observers consume them. ]
h3 => [ 28) What do you understand by Elasticity in contrast to Scalability?  ]
p => [ In the IT infrastructure, the term "Elasticity" can be defined as the ability to quickly expand or cut back capacity and services without obstructing the infrastructure's stability, performance, security, governance or compliance protocols. ]
p => [ It means that the throughput of a system scales up or down automatically to meet varying demand as a resource is proportionally added or removed. The system needs to be scalable to allow it to benefit from the dynamic addition or removal of resources at runtime. Elasticity, therefore, builds upon Scalability and expands on it by adding the notion of automatic resource management. ]
h3 => [ 29) What is the difference between Failure and Error?  ]
th => [ Failure ]
th => [ Error ]
td => [ A failure can be defined as an unexpected event within a service that prevents it from functioning normally. When a failure occurs, it can generally prevent responses to the current and possibly all following client requests. ]
td => [ Errors are different from failures. An error is a common condition that can appear during input validation that will be communicated to the client as part of the message's normal processing. ]
td => [ Failures are unexpected, and they require intervention before the system can resume at the same level of operation as earlier. ]
td => [ Errors are an expected part of normal operations. We can deal with errors immediately, and the system will continue to operate at the same capacity following an error. ]
td => [ It does not mean that failures are always fatal. Rather, some capacity of the system will be reduced following a failure. ]
td => [ Errors are not fatal. They are part of the programming and can be occurred anytime. ]
h3 => [ 30) What is the difference between Imperative, Functional and Reactive Programming?  ]
p => [ Let's compare them to see the difference: ]
p => [  Imperative Programming:  Imperative programming is a programming paradigm where each line of code is sequentially executed to produce the desired result. This programming paradigm forces programmers to write "how" a program will solve a certain task. ]
p => [  Functional Programming:  Functional programming is a programming paradigm where we can set everything as a result of a function that avoids changing states and mutating data. ]
p => [  Reactive Programming:  Reactive programming is a programming paradigm with asynchronous data streams or event streams. An event stream can be anything like keyboard inputs, button taps, gestures, GPS location updates, accelerometer, iBeacon etc. Here, we can listen to a stream and react to it according to the situation. ]
h3 => [ 31) What do you understand by to be Resilient for a Reactive System?  ]
p => [ To be Resilient for a Reactive System means the system will stay responsive if it gets any chance of failure. Any system that is not resilient will be unresponsive after a failure. Resilience is achieved by replication, containment, isolation and delegation. Failures are contained within each component, isolating components from each other, thereby ensuring that parts of the system can fail and recover without compromising the entire system. ]
a => [ Interview Tips ]
a => [ Job/HR Interview Questions ]
a => [ Company Interview Questions &amp; Procedure ]
a => [ JavaScript Interview Questions ]
a => [ Java Basics Interview Questions ]
a => [ Java OOPs Interview Questions ]
a => [ Servlet Interview Questions ]
a => [ JSP Interview Questions ]
span => [ Spring Interview Questions ]
span => [ Hibernate Interview Questions ]
span => [ PL/SQL Interview Questions ]
span => [ SQL Interview Questions ]
span => [ Oracle Interview Questions ]
span => [ Android Interview Questions ]
a => [ jQuery Interview Questions ]
span => [ MySQL Interview Questions ]
h2 => [ You may also like: ]
a => [ Java Interview Questions ]
a => [ SQL Interview Questions ]
a => [ Python Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ Angular Interview Questions ]
a => [ Selenium Interview Questions ]
a => [ Spring Boot Interview Questions ]
a => [ HR Interview Questions ]
a => [ C Programming Interview Questions ]
a => [ C++ Interview Questions ]
a => [ Data Structure Interview Questions ]
a => [ DBMS Interview Questions ]
a => [ HTML Interview Questions ]
a => [ IAS Interview Questions ]
a => [ Manual Testing Interview Questions ]
a => [ OOPs Interview Questions ]
a => [ .Net Interview Questions ]
a => [ C# Interview Questions ]
a => [ ReactJS Interview Questions ]
a => [ Networking Interview Questions ]
a => [ PHP Interview Questions ]
a => [ CSS Interview Questions ]
a => [ Node.js Interview Questions ]
a => [ Spring Interview Questions ]
a => [ Hibernate Interview Questions ]
a => [ AWS Interview Questions ]
a => [ Accounting Interview Questions ]
h2 => [ Learn Latest Tutorials ]
p => [ Splunk ]
p => [ SPSS ]
p => [ Swagger ]
p => [ Transact-SQL ]
p => [ Tumblr ]
p => [ ReactJS ]
p => [ Regex ]
p => [ Reinforcement Learning ]
p => [ R Programming ]
p => [ RxJS ]
p => [ React Native ]
p => [ Python Design Patterns ]
p => [ Python Pillow ]
p => [ Python Turtle ]
p => [ Keras ]
h2 => [ Preparation ]
p => [ Aptitude ]
p => [ Reasoning ]
p => [ Verbal Ability ]
p => [ Interview Questions ]
p => [ Company Questions ]
h2 => [ Trending Technologies ]
p => [ Artificial Intelligence ]
p => [ AWS ]
p => [ Selenium ]
p => [ Cloud Computing ]
p => [ Hadoop ]
p => [ ReactJS ]
p => [ Data Science ]
p => [ Angular 7 ]
p => [ Blockchain ]
p => [ Git ]
p => [ Machine Learning ]
p => [ DevOps ]
h2 => [ B.Tech / MCA ]
p => [ DBMS ]
p => [ Data Structures ]
p => [ DAA ]
p => [ Operating System ]
p => [ Computer Network ]
p => [ Compiler Design ]
p => [ Computer Organization ]
p => [ Discrete Mathematics ]
p => [ Ethical Hacking ]
p => [ Computer Graphics ]
p => [ Software Engineering ]
p => [ Web Technology ]
p => [ Cyber Security ]
p => [ Automata ]
p => [ C Programming ]
p => [ C++ ]
p => [ Java ]
p => [ .Net ]
p => [ Python ]
p => [ Programs ]
p => [ Control System ]
p => [ Data Mining ]
p => [ Data Warehouse ]
