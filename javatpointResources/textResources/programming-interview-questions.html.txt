
div => [ 
 ]
h1 => [ Programming Interview Questions ]
p => [ Only knowing the theoretical aspects of Java is not sufficient to crack the interview. One of the most important rounds for becoming a Java developer is the programming round, where the interviewee is asked to code. Writing optimized code is a must for becoming a Java developer. In this tutorial, we will discuss some advanced programming interview questions.  ]
h3 => [ 1) Given an integer array arr of size s. Now, check whether there exists at least one element which is strictly smaller than all the elements on the right of it and greater than all the elements on the left of it. If it exists, return true; otherwise, return false. Ignore the corner elements of the given array. ]
strong => [ Example: 1 ]
p => [ arr[] = {3, 4, 5, 1, 6, 10, 9, 7, 8}; s = 9 ]
p => [  Ans:  true ]
p => [  Explanation:  All the numbers that are coming before 6 are smaller than 6, and all the elements that are coming after 6 are greater than 6. Hence, the answer is true. ]
strong => [ Example: 2 ]
p => [ arr[] = {4, 5, 1}; s = 3 ]
p => [  Ans:  false ]
p => [  Explanation:  There is not a single number that fits the given condition. Hence, the answer is false. ]
p => [  FileName:  PeakElement.java ]
strong => [ Output: ]
h3 => [ 2) Given a read-only array arr of size s, such that each element of the array can not exceed the value s. Also, in the array, each element occurs only once except a1, which is occurring twice, and therefore, a2 is missing. Find out the value of a1 and a2. Note that read-only means any modification in the input array is not allowed. ]
strong => [ Example: 1 ]
p => [ arr[] = {1, 3, 5, 2, 3}; s = 5 ]
p => [  Ans:  a1 = 3, a2 = 4 ]
p => [  Explanation:  The repeating number is 3, and the missing number is 4. ]
strong => [ Example: 2 ]
p => [ arr[] = {1, 2, 1}; s = 3 ]
p => [  Ans:  a1 = 1, a2 = 3 ]
p => [  Explanation:  The repeating number is 1, and the missing number is 3. ]
p => [  FileName:  MissingAndRepeatingElement.java ]
strong => [ Output: ]
h3 => [ 3) Given a read-only array arr of size s. Find out the number of ways one can divide the array arr into 3 parts such that the sum of each part is equal. ]
strong => [ Example: 1 ]
p => [ arr[] = {0, 1, -1, 0}; s = 4 ]
p => [  Ans:  1 ]
p => [  Explanation:  There is only one way to split the array into three parts whose sum is equal. {0}, {1, -1}, {0} ]
p => [  Example:  2 ]
p => [ arr[] = {2, 2, 4, 0, 4}; s = 5 ]
p => [  Ans:  2 ]
p => [  Explanation:  There are two ways to split the array into three parts whose sum is equal. ]
p => [ {2, 2}, {4, 0}, {4} ]
p => [ {2, 2}, {4}, {0, 4} ]
p => [  FileName:  ParititionArray.java ]
strong => [ Output: ]
h3 => [ 4) An array arr of N integers X1, X2, X3, ...., Xn is given. You have to return the maximum value of f(a1, a2), where 0 â‰¤ a1, a2, &lt; N. It is given that f(a1, a2) = |arr[a1] - a[a2]| + |a1 - a2|, where |y| represents the absolute value of y. ]
strong => [ Example: 1 ]
p => [ arr[] = {1, -1, 3}; ]
p => [  Ans:  5 ]
strong => [ Explanation: ]
p => [ f(0, 0) = f(1, 1) = f(2, 2) = 0 ]
p => [ f(0, 1) = f(1, 0) = 3 ]
p => [ f(0, 2) = f(2, 0) = 4 ]
p => [ f(1, 2) = f(2, 1) = 5 ]
p => [ We see that the maximum value is 5. Hence, the answer is 5. ]
strong => [ Example: 2 ]
p => [ arr[] = {2, -1, -1, 3}; ]
p => [  Ans:  6 ]
strong => [ Explanation: ]
p => [ f(0, 0) = f(1, 1) = f(2, 2) = f(3, 3) = 0 ]
p => [ f(0, 1) = f(1, 0) = 4 ]
p => [ f(0, 2) = f(2, 0) = 5 ]
p => [ f(0, 3) = f(3, 0) = 4 ]
p => [ f(1, 2) = f(2, 1) = 1 ]
p => [ f(1, 3) = f(3, 1) = 6 ]
p => [ f(2, 3) = f(3, 2) = 5 ]
p => [ We see that the maximum value is 6. Hence, the answer is 6. ]
p => [  FileName:  AbsoluteValue.java ]
strong => [ Output: ]
h3 => [ 5) Find the next permutation of the number that is formed by the elements of the array arr of size s without changing the order of elements.  ]
strong => [ Example: 1 ]
p => [ arr[] = {3, 1, 2}; s = 3; ]
p => [  Ans:  321 ]
p => [  Explanation:  The number formed using the array elements is 312. The next permutation of the number 312 is 321. ]
strong => [ Example: 2 ]
p => [ arr[] = {1, 2, 3}; ]
p => [  Ans:  132 ]
p => [  Explanation:  The number formed using the array elements is 123. The next permutation of the number 123 is 132. ]
p => [  FileName:  NextPermutation.java ]
strong => [ Output: ]
h3 => [ 6) There is an array arr, which contains only non-negative numbers. Create the largest number using all of the non-negative numbers of the given array arr. ]
strong => [ Example: 1 ]
p => [ arr[] = {35, 1, 9}; ]
p => [  Ans:  9351 ]
p => [  Explanation:  9 is the largest number digit, so it will be put first. After that, the digit 3 is greater than digit 1. Therefore, 35 is put before 1. ]
strong => [ Example: 2 ]
p => [ arr[] = {17, 22, 83, 7, 5}; ]
p => [  Ans:  83752217 ]
p => [  Explanation:  8 is the largest digit in the given array. Therefore, 83 is put first. The same treatment is given to other numbers too. ]
p => [  FileName:  LargestNoExample.java ]
strong => [ Output: ]
h3 => [ 7) A 2-dimensional matrix containing m rows and m columns is given. The task is to do the rotation of the matrix by 90 degrees in a clockwise manner. ]
strong => [ Example: 1 ]
strong => [ Example: 2 ]
p => [  FileName:  RotateMatrix.java ]
strong => [ Output: ]
h3 => [ 8) There is an array arr, which contains only non-negative numbers. Find the subarray of the smallest size from the given array arr, which gets sorted; then the whole array gets sorted. ]
strong => [ Example: 1 ]
p => [ arr[] = {2, 4, 3, 8, 9}; ]
p => [  Ans:  {1, 2} ]
p => [  Explanation:  The subarray starting from index 1 and ending at index 2 is the smallest subarray that gets sorted, then the whole array gets sorted. ]
strong => [ Example: 2 ]
p => [ arr[] = {12, 34, 45, 67, 78, 88, 99, 102}; ]
p => [  Ans:  { } ]
p => [  Explanation:  The given array is already sorted. Hence, the subarray is empty. ]
p => [  FileName:  SmallestSubArray.java ]
strong => [ Output: ]
h3 => [ 9) An array arr with size sz, a key k, and the segment size s is given, such that s completely divides sz. Check whether each segment of the array arr of size s has the key k present or not. ]
strong => [ Example: 1 ]
p => [ arr[] = {5, 3, 2, 4, 3, 9, 11, 3, 12, 67, 45, 3}; sz = 12; k = 3; s = 3; ]
p => [  Ans:  Yes, each segment of the array arr of size s contains the key k. ]
p => [  Explanation:  sz / s = 12 / 3 = 4. These four segments are: ]
p => [ {5, 3, 2} -----&gt; contains the key 3 ]
p => [ {4, 3, 9} -----&gt; contains the key 3 ]
p => [ {11, 3, 12} -----&gt; contains the key 3 ]
p => [ {67, 45, 3} -----&gt; contains the key 3 ]
p => [ Thus, each segment contains the key k, which is 3. ]
strong => [ Example: 2 ]
p => [ arr[] = {23, 56, 65, 21, 34, 67, 89, 9, 0, 23, 55, 44, 33, 22, 23}; sz = 15; k = 23; s = 5; ]
p => [  Ans:  Yes, each segment of the array arr of size s contains the key k. ]
p => [  Explanation:  sz / s = 15 / 5 = 3. These three segments are: ]
p => [ {23, 56, 65, 21, 34} -----&gt; contains the key 23 ]
p => [ {67, 89, 9, 0, 23} -----&gt; contains the key 23 ]
p => [ {55, 44, 33, 22, 23} -----&gt; contains the key 23 ]
p => [ Thus, each segment contains the key k, which is 23. ]
p => [  FileName:  ArraySegmentKey.java ]
strong => [ Output: ]
h3 => [ 10) Given a string, the task is to search the rank of the given string amongst its lexicographically sorted permutations. The characters of the given string may or may not be repeated. If the characters are repeated, one needs to look at the unique permutations and then determine the rank. ]
strong => [ Example: 1 ]
p => [ str = "caa" ]
p => [  Ans:  The rank of "caa" is 3 among its lexicographically sorted permutations. ]
p => [  Explanation:  The string has three characters, 'a', 'a', and 'c', and their lexicographically sorted permutations are: ]
p => [ "aac" ----------&gt; rank - 1 ]
p => [ "aca" ----------&gt; rank - 2 ]
p => [ "caa" ----------&gt; rank - 3 ]
p => [ Hence, the rank is 3. ]
strong => [ Example: 2 ]
p => [ str = "dcab" ]
p => [  Ans:  The rank of "dcab" is 23 among its lexicographically sorted permutations. ]
p => [  Explanation:  The string has four characters, 'a', 'b', 'c', 'd', and their lexicographically sorted permutations are: ]
p => [ "abcd" ----------&gt; rank - 1 ]
p => [ "abdc" ----------&gt; rank - 2 ]
p => [ "acbd" ----------&gt; rank - 3 ]
p => [ "acdb" ----------&gt; rank - 4 ]
p => [ "adbc" ----------&gt; rank - 5 ]
p => [ "adcb" ----------&gt; rank - 6 ]
p => [ "bacd" ----------&gt; rank - 7 ]
p => [ "badc" ----------&gt; rank - 8 ]
p => [ "bcad" ----------&gt; rank - 9 ]
p => [ "bcda" ----------&gt; rank - 10 ]
p => [ "bdac" ----------&gt; rank - 11 ]
p => [ "bdca" ----------&gt; rank - 12 ]
p => [ "cabd" ----------&gt; rank - 13 ]
p => [ "cadb" ----------&gt; rank - 14 ]
p => [ "cbad" ----------&gt; rank - 15 ]
p => [ "cbda" ----------&gt; rank - 16 ]
p => [ "cdab" ----------&gt; rank - 17 ]
p => [ "cdba" ----------&gt; rank - 18 ]
p => [ "dabc" ----------&gt; rank - 19 ]
p => [ "dacb" ----------&gt; rank - 20 ]
p => [ "dbac" ----------&gt; rank - 21 ]
p => [ "dbca" ----------&gt; rank - 22 ]
p => [ "dcab" ----------&gt; rank - 23 ]
p => [ Hence, the rank is 23. ]
p => [  FileName:  PermutationRank.java ]
strong => [ Output: ]
h3 => [ 11) Given two sorted arrays, arr and arr1. Their size may not be or maybe equal. Find the median of these given arrays. Note that merging of the sorted arrays is not allowed. ]
strong => [ Example: 1 ]
p => [ arr = {-11, -10, -9, -2, 5, 17} ]
p => [ arr1 = {-4, 4, 7, 13, 16, 17, 19} ]
p => [  Ans:  The median of these sorted arrays is at the index. ]
p => [  Explanation:  When these sorted arrays are merged, we get the following. ]
p => [ mergedArray = {-11, -10, -9, -4, -2, 4, 5, 7, 13, 16, 17, 17, 19}; ]
p => [  The size of the mergedArray is 13, which is odd. Hence, there is only one middle element sitting at the index 13 / 2 = 6. At the 6 th  index, we get 5. Hence, 5 is the median of these sorted arrays.  ]
h4 => [ Note: We are merging it here only for the explanation purpose. In the code, we will not merge the arrays. ]
strong => [ Example: 2 ]
p => [ arr = {5, 7, 9, 11, 13, 16, 19, 22} ]
p => [ arr1 = {-4, 4, 7, 8, 10, 11, 12, 14} ]
p => [  Ans:  The median of these sorted arrays is 10. ]
p => [  Explanation:  When these sorted arrays are merged, we get the following. ]
p => [ mergedArray = {-4, 4, 5, 7, 7, 8, 9, 10, 11, 11, 12, 13, 14, 16, 19, 22}; ]
p => [  The size of the mergedArray is 16, which is even. Hence, there are two middle elements which are sitting at 16 / 2 = 8 th  and 16 / 2 - 1 = 7 th  indices. Thus, the median is (10 + 11) / 2 = 10.5. ]
p => [  FileName:  FindMedian.java ]
strong => [ Output: ]
h3 => [ 12) Given an array arr whose size is s. Also, an integer tar is given. The array arr is rotated using an element of the array as pivot {1, 2, 3, 4, 5} might become {4, 5, 1, 2, 3}. Find whether the integer tar is present in the array arr or not. Note that the array arr is sorted in non-decreasing order before the rotation.  ]
strong => [ Example: 1 ]
p => [ arr = {7, 8, 9, 10, 0, 3, 4, 5, 6}; s = 9; tar = 3; ]
p => [  Ans:  5. ]
p => [  Explanation:  the number 3 is present at the index 5. ]
strong => [ Example: 2 ]
p => [ arr = {4, 5, 1, 2, 3}; s = 5; tar = 6; ]
p => [  Ans:  -1 ]
p => [  Explanation:  the number 6 is not present in the array. ]
p => [  FileName:  FindElement.java ]
strong => [ Output: ]
h4 => [ Note: The linear search will also do the job here. However, its time complexity would be more as compared to the binary search. ]
h3 => [ 13) Given an array arr whose size is s. The array arr is sorted in non-decreasing order. Also, an integer tar is given. Find whether the integer tar is present in the array arr or not. If present, find the starting and ending indices of the integer tar. ]
strong => [ Example: 1 ]
p => [ arr = {1, 2, 3, 4, 5, 5, 5, 5, 6, 7, 8, 9, 10}; s = 13; tar = 5; ]
p => [  Ans:  starting index: 4, ending index: 7 ]
p => [  Explanation:  Between the indices 4 to 7, the number 5 is present. ]
strong => [ Example: 2 ]
p => [ arr = {8, 10, 12, 56, 67, 70, 70, 70, 70, 75, 77, 78, 90, 93, 97}; s = 15; tar = 19; ]
p => [  Ans:  The target number 19 is not present in the given array ]
p => [  FileName:  FindRange.java ]
strong => [ Output: ]
h3 => [ 14) A string str is given. Find the minimum of characters added to the string str to make it a palindrome string. The characters must be added at the beginning of the string. ]
strong => [ Example: 1 ]
p => [ str = "ABC"; ]
p => [  Ans:  2 ]
p => [  Explanation:  Inserting "B" at the beginning, we get B + ABC ---&gt; BABC. ]
p => [ Inserting "C" at the beginning, we get C + BABC ---&gt; CBABC. Thus, there are 2 insert operations. Hence, the answer is 2. ]
strong => [ Example: 2 ]
p => [ str = "ABEBAAAA"; ]
p => [  Ans:  3 ]
p => [  Explanation:  Inserting "A" at the beginning, we get A + ABEBAAAA ---&gt; AABEBAAAA. ]
p => [ Inserting "A" at the beginning, we get A + AABEBAAAA ---&gt; AAABEBAAAA. ]
p => [ Inserting "A" at the beginning, we get A + AAABEBAAAA ---&gt; AAAABEBAAAA. ]
p => [ Thus, there are 3 insert operations. Hence, the answer is 3. ]
p => [  FileName:  MakePalindrome.java ]
strong => [ Output: ]
h3 => [ 15) An array of strings and a number n is given. Format the strings present in the array in such a way that each line contains n characters. Insert the strings using the greedy approach, which means insert as many words or characters as one can in a line. Use ' ' character for the padding purpose so that each line has n characters. The extra spaces should be evenly distributed. If the number of spaces does not divide the strings evenly, then the left slot should have more spaces as compared to the right ones. For the last line, the text should be left-justified, i.e., extra spaces should be more on the right side. ]
strong => [ Example: ]
p => [ Words = {"It", "is", "the", "example", "of", "sorting", "technique"} ]
p => [ N = 16 ]
p => [  Ans:  the formatted lines are: ]
p => [  FileName:  TextJustified.java ]
strong => [ Output: ]
h3 => [ 16) An integer array arr is given such that every number is repeated thrice, barring one, which is repeated only once. Return the number that is repeated only once. ]
strong => [ Example: ]
p => [ arr[] ={2, 2, 2, 4, 6, 6, 6, 5, 4, 9, 9, 9, 0, 0, 4, 0} ]
p => [  Ans:  5 ]
p => [  Explanation:  Number 5 is only repeated once. ]
p => [  FileName:  UniqueNumber.java ]
strong => [ Output: ]
h3 => [ 17) An integer array arr is given. Rearrange array arr such that arr[i] = arr[arr[i]]. The space complexity must be O(1). ]
strong => [ Example: ]
p => [ arr[] = {2, 1, 0} ]
p => [  Ans:  {0, 1, 2}; ]
p => [  Explanation:  arr[0] = 2 =&gt; arr[arr[0]] becomes arr[2] = 0; ]
p => [ arr[1] = 1 =&gt; arr[arr[1]] = arr[1] = 1 ]
p => [ arr[2] = 0 =&gt; arr[arr[2]] = arr[0] = 2 ]
p => [ Thus, the updated array is {0, 1, 2} ]
p => [  FileName:  RearrangeArray.java ]
strong => [ Output: ]
h4 => [ Note: if the O(1) space complexity condition is removed, then the problem is straightforward. One can create an array of the same size as of input array and can copy the values of a[a[i]] to the recently created array. The O(1) space complexity makes the problem tricky. ]
h3 => [ 18) A positive number n is given. Find the number of trailing zeros that are present in the binary representation of the number. ]
strong => [ Example: 1 ]
p => [ n = 20 ]
p => [  Ans:  2 ]
p => [  Explanation:  The binary representation of 20 is 10100. The total number of trailing zeros present in 10100 is 2. Hence, the answer is 2. ]
strong => [ Example: 2 ]
p => [ n = 9 ]
p => [  Ans:  0 ]
p => [  Explanation:  The binary representation of 9 is 1001. The total number of trailing zeros present in 1001 is 0. Hence, the answer is 0. ]
p => [  FileName:  TrailingZeros.java ]
strong => [ Output: ]
sup => [ th ]
strong => [ Example: 1 ]
p => [ n = 1 ]
p => [  Ans:  1 ]
p => [  Explanation:  The binary representation of 1 is 1, and 1 is a palindrome. 1 is also the 1 st  number. ]
strong => [ Example: 2 ]
p => [ n = 3 ]
p => [  Ans:  5 ]
p => [  Explanation:  The 3 rd  number whose binary representation is a palindrome is 5. Its binary representation is 101. ]
p => [ Example: 3 ]
p => [ n = 9 ]
p => [  Ans:  27 ]
p => [  Explanation:  The 9 th  number whose binary representation is a palindrome is 27. Its binary representation is 11011. ]
p => [  FileName:  PalindromeNumbers.java ]
strong => [ Output: ]
h3 => [ 20) An array arr of integers is given. Also, a sliding window of size w is moving from the left side to the right side of the array. Thus, at a time, one can only watch w numbers. The task is to find the maximum for each window. Observe the following examples. ]
strong => [ Example: ]
p => [ arr[] = {1, 4, -1, -4, 6, 4, 7, 8}; w = 3; ]
p => [  Ans:  {4, 4, 6, 6, 7, 8} ]
strong => [ Explanation: ]
p => [ {[1, 4, -1,] -4, 6, 4, 7, 8} -&gt; max(1, 4, -1) = 4 ]
p => [ {1, [4, -1, -4,] 6, 4, 7, 8} -&gt; max(4, -1, -4) = 4 ]
p => [ {1, 4, [-1, -4, 6,] 4, 7, 8} -&gt; max(-1, -4, 6) = 6 ]
p => [ {1, 4, -1, [-4, 6, 4,] 7, 8} -&gt; max(-4, 6, 4) = 6 ]
p => [ {1, 4, -1, -4, [6, 4, 7,] 8} -&gt; max(6, 4, 7) = 7 ]
p => [ {1, 4, -1, -4, 6, [4, 7, 8]} -&gt; max(4, 7, 8) = 8 ]
p => [  FileName:  SlidingWindowMax.java ]
strong => [ Output: ]
h3 => [ 21) An arithmetic expression is given in Reverse Polish Notation. Evaluate the given expression. ]
strong => [ Example: ]
p => [ A = ["4", "3", "+", "5", "*"] ]
p => [  Ans:  35 ]
strong => [ Explanation: ]
p => [ * -&gt; () * () ]
p => [ 5: -&gt; () * (5) ]
p => [ +: (() + ()) * (5) ]
p => [ 3: (() + (3)) * (5) ]
p => [ 4: ((4) + (3)) * (5) ]
p => [ = (7) * (5) = 35 ]
p => [  FileName:  EvaluateExpression.java ]
strong => [ Output: ]
h3 => [ 22) A number n is given, which represents the total number of bits present in the code. The gray code always starts from 0. Display the sequence of the gray code. ]
strong => [ Example: ]
p => [ N = 3; ]
p => [  Ans:  {0, 1, 3, 2, 6, 7, 5, 4} ]
p => [ 0 0 0 ---&gt; 0 ]
p => [ 0 0 1 ---&gt; 1 ]
p => [ 0 1 1 ---&gt; 3 ]
p => [ 0 1 0 ---&gt; 2 ]
p => [ 1 1 0 ---&gt; 6 ]
p => [ 1 1 1 ---&gt; 7 ]
p => [ 1 0 1 ---&gt; 5 ]
p => [ 1 0 0 ---&gt; 4 ]
p => [  FileName:  GrayCode.java ]
strong => [ Output: ]
h3 => [ 23) An array arr containing n integers is given. Find all the unique triplets (x, y, and z) such that x + y + z = 0. Note that ordering of triplets does not matter, i.e., y + z + x or y + x + z is the same as x + y + z. ]
strong => [ Example: ]
p => [ arr = {-2, 0, 2, 4, -2, -4}; ]
p => [  Ans:  There are three unique triplets. {-2, 0, 2}, {-2, -2, 4}, {-4, 0, 4} ]
p => [  FileName:  FindTriplets.java ]
strong => [ Output: ]
h3 => [ 24) There is an array arr, which contains only non-negative integers (x1, x2, x3, ..., xn). Each of which represents the coordinate (j, xj). 'n' vertical lines are stretched such that the two endpoints of the line j is at (j, xj) and (j, 0). Find such two lines, which simultaneously with the x-axis creates a container, such that the container fetches the maximum amount of water. Assume that the water can be stored in the 2-D container. Note that slanting the container is not allowed. ]
strong => [ Example: 1 ]
p => [ arr = {5, 1, 2, 3}; ]
p => [  Ans:  9 ]
p => [  Explanation:  There are 4 vertical lines in the given array, which are of height 5, 1, 2, and 3, respectively. Also, 5 and 3 are 3 distances apart. So, the capacity is min(5, 3) * 3 = 9. If we take any other pair of the vertical lines, we do not get a capacity of more than 9. ]
p => [  FileName:  ContainerCapacity.java ]
strong => [ Output: ]
h3 => [ 25) An array arr of n integers is given. x1, x2 ,..., xn and an integer J. Return the count of unique numbers present in all windows whose size is J.  ]
strong => [ Example: 1 ]
p => [ arr = {5, 1, 2, 3, 2, 5, 9, 8, 0, 0, 0}; J = 3 ]
p => [  Ans:  {3, 3, 2, 3, 3, 3, 3, 2, 1} ]
p => [  Explanation:  All the windows of size J, which is 3, are: ]
p => [ {5, 1, 2} ---&gt; 3 unique numbers ]
p => [ {1, 2, 3} ---&gt; 3 unique numbers ]
p => [ {2, 3, 2} ---&gt; 2 unique numbers ]
p => [ {3, 2, 5} ---&gt; 3 unique numbers ]
p => [ {2, 5, 9} ---&gt; 3 unique numbers ]
p => [ {5, 9, 8} ---&gt; 3 unique numbers ]
p => [ {9, 8, 0} ---&gt; 3 unique numbers ]
p => [ {8, 0, 0} ---&gt; 2 unique numbers ]
p => [ {0, 0, 0} ---&gt; 1 unique number ]
p => [ If we make a list of unique elements, we get {3, 3, 2, 3, 3, 3, 3, 2, 1}. ]
p => [  FileName:  UniqueNumbers.java ]
strong => [ Output: ]
h3 => [ 26) An array arr containing only integers is given. Find 4 indices from the array arr such that arr[i] + arr[j] = arr[k] + arr[l] where i, j, k, &amp;, l are the 4 indices. In the case of multiple answers, display any one set of 4 indices, which satisfies the given condition. Note that all the indices have to be unique. ]
strong => [ Example: 1 ]
p => [ arr = {-2, 0, 2, 4, -2, -4}; ]
p => [  Ans:  {0, 1, 2, 5} ]
p => [  Explanation:  Values at the indices 0, 1, 2, and, 5 are -2, 0, 2, and, -4 respectively, and ]
p => [ -2 + 0 = 2 + -4 =&gt; 2. Other answer can be {0, 2, 3, 5}, or {1, 2, 3, 4} ]
p => [  FileName:  EqualSum.java ]
strong => [ Output: ]
h3 => [ 27) A string str and a string X are given. Look for the minimum window in str, which contains all the characters in X. The time complexity has to be linear. Note that the size of the window has to be equal to or greater than the size of string X. ]
strong => [ Example: 1 ]
p => [ S = "APPLBEXODEBLBNC" ]
p => [ X = "LNC" ]
p => [  Ans:  "LBNC" ]
p => [  Explanation:  Any other window will take more characters. The window of minimum size is mentioned in the answer. ]
p => [  FileName:  SmallestWindow.java ]
strong => [ Output: ]
h3 => [ 28) A one-dimensional integer array arr of length l is given. What is the length of the longest subsequence, which is first increasing and then decreasing? ]
strong => [ Example: ]
p => [ arr = {2, 11, 3, 10, 5, 4, 3, 2, 1}; l = 9 ]
p => [  Ans:  8 ]
p => [  Explanation:  The longest subsequence which is increasing and then decreasing is {2, 3, 10, 5, 4, 3, 2, 1}. There are 8 elements in it. Hence, the answer is 8. ]
p => [  FileName:  LongestSubsequence.java ]
strong => [ Output: ]
h3 => [ 29) A set of coins X is given. Find out the number of ways one can make the sum S. Note that there is an infinite supply of the coins mentioned in the set X. Ensure that the space complexity is O(S). Note that ordering of coins should be ignored, i.e, 1 + 2 = 3 is one way; therefore, 2 + 1 = 3 won't be considered or vice versa. Also, set of coins will always be in ascending order. ]
strong => [ Example: ]
p => [ X = {2, 3, 5, 7}; S = 15 ]
p => [  Ans:  10 ]
p => [  Explanation:  There are 10 ways to get the sum S = 15. Following are those 10 ways: ]
p => [ 2 + 2 + 2 + 2 + 2 + 2 + 3 = 15 ]
p => [ 2 + 2 + 2 + 3 + 3 + 3 = 15 ]
p => [ 2 + 2 + 2 + 2 + 2 + 5 = 15 ]
p => [ 2 + 3 + 5 + 5 = 15 ]
p => [ 2 + 2 + 3 + 3+ 5 = 15 ]
p => [ 2 + 2 + 2 + 2 + 7 = 15 ]
p => [ 2 + 3 + 3 + 7 = 15 ]
p => [ 3 + 3 + 3 + 3 + 3 = 15 ]
p => [ 3 + 5 + 7 = 15 ]
p => [ 5 + 5 + 5 = 15 ]
p => [  FileName:  CoinSum.java ]
strong => [ Output: ]
h3 => [ 30) A chessboard of size R * C is given, where R represents the total number of rows, and C represents the total number of columns. Create a matrix arr, such that arr[x][y] represents the number of queen attacks occurring on the cell(x, y), assuming there is no queen present at the cell. ]
strong => [ Note: ]
strong => [ 1) Queen moves any number of squares at a time in the vertical direction, horizontal direction, or diagonally on any chessboard. A queen is not a knight; therefore, it can not jump over other queens. ]
strong => [ 2) An array of R strings is given, each of the size C. The string only contains '0' and '1'. 1 represents queen, and 0 means empty cell. Thus, at any cell, either a queen is present, or the cell is empty. ]
strong => [ 3) The worst time complexity can not exceed O(R * C). ]
strong => [ Example: ]
p => [ Suppose the chessboard be ]
p => [ [1 0 0] ]
p => [ [0 0 1] ]
p => [ [0 1 0] ]
p => [ Where 1 is the queen position and 0 is empty. ]
p => [ No queen attacks the cell(1, 1). Remember, we have to assume that no queen is present at the cell which we are evaluating for the attack. ]
p => [ 3 attacks are coming from the queens to the cell (1, 2). One from the queen at the cell(1, 1), one from the queen at the cell(2, 3), and another from the cell(3, 2). ]
p => [ Queens at (2, 3) and (1, 1) attack the cell(1, 3). Note that we have considered 1-indexing this time. ]
p => [ Similarly, we can calculate the queen attack for other cells too. ]
p => [ The final matrix is: ]
p => [ [0, 3, 2] ]
p => [ [3, 3, 1] ]
p => [ [2, 1, 3] ]
p => [  FileName:  QueenAttack.java ]
strong => [ Output: ]
h2 => [ You may also like: ]
a => [ Java Interview Questions ]
a => [ SQL Interview Questions ]
a => [ Python Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ Angular Interview Questions ]
a => [ Selenium Interview Questions ]
a => [ Spring Boot Interview Questions ]
a => [ HR Interview Questions ]
a => [ C Programming Interview Questions ]
a => [ C++ Interview Questions ]
a => [ Data Structure Interview Questions ]
a => [ DBMS Interview Questions ]
a => [ HTML Interview Questions ]
a => [ IAS Interview Questions ]
a => [ Manual Testing Interview Questions ]
a => [ OOPs Interview Questions ]
a => [ .Net Interview Questions ]
a => [ C# Interview Questions ]
a => [ ReactJS Interview Questions ]
a => [ Networking Interview Questions ]
a => [ PHP Interview Questions ]
a => [ CSS Interview Questions ]
a => [ Node.js Interview Questions ]
a => [ Spring Interview Questions ]
a => [ Hibernate Interview Questions ]
a => [ AWS Interview Questions ]
a => [ Accounting Interview Questions ]
h2 => [ Learn Latest Tutorials ]
p => [ Splunk ]
p => [ SPSS ]
p => [ Swagger ]
p => [ Transact-SQL ]
p => [ Tumblr ]
p => [ ReactJS ]
p => [ Regex ]
p => [ Reinforcement Learning ]
p => [ R Programming ]
p => [ RxJS ]
p => [ React Native ]
p => [ Python Design Patterns ]
p => [ Python Pillow ]
p => [ Python Turtle ]
p => [ Keras ]
h2 => [ Preparation ]
p => [ Aptitude ]
p => [ Reasoning ]
p => [ Verbal Ability ]
p => [ Interview Questions ]
p => [ Company Questions ]
h2 => [ Trending Technologies ]
p => [ Artificial Intelligence ]
p => [ AWS ]
p => [ Selenium ]
p => [ Cloud Computing ]
p => [ Hadoop ]
p => [ ReactJS ]
p => [ Data Science ]
p => [ Angular 7 ]
p => [ Blockchain ]
p => [ Git ]
p => [ Machine Learning ]
p => [ DevOps ]
h2 => [ B.Tech / MCA ]
p => [ DBMS ]
p => [ Data Structures ]
p => [ DAA ]
p => [ Operating System ]
p => [ Computer Network ]
p => [ Compiler Design ]
p => [ Computer Organization ]
p => [ Discrete Mathematics ]
p => [ Ethical Hacking ]
p => [ Computer Graphics ]
p => [ Software Engineering ]
p => [ Web Technology ]
p => [ Cyber Security ]
p => [ Automata ]
p => [ C Programming ]
p => [ C++ ]
p => [ Java ]
p => [ .Net ]
p => [ Python ]
p => [ Programs ]
p => [ Control System ]
p => [ Data Mining ]
p => [ Data Warehouse ]
