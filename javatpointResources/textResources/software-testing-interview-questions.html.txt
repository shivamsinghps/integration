
div => [ 
 ]
h1 => [ Software Testing Interview Questions ]
p => [  A list of mostly asked  software testing interview questions  or  QTP interview questions  and answers are given below. ]
h3 => [ 1) What is the PDCA cycle and where testing fits in? ]
p => [ There are four steps in a normal software development process. In short, these steps are referred to as PDCA. ]
p => [ PDCA stands for Plan, Do, Check, Act. ]
strong => [ Plan: ]
strong => [ Do/ Execute: ]
strong => [ Check: ]
strong => [ Act: ]
p => [ The developers do the "planning and building" of the project while testers do the "check" part of the project. ]
h3 => [ 2) What is the difference between the white box, black box, and gray box testing? ]
p => [  Black box Testing:  The strategy of black box testing is based on requirements and specification. It requires no need of knowledge of internal path, structure or implementation of the software being tested. ]
p => [  White box Testing:  White box testing is based on internal paths, code structure, and implementation of the software being tested. It requires a full and detail programming skill. ]
p => [  Gray box Testing:  This is another type of testing in which we look into the box which is being tested, It is done only to understand how it has been implemented. After that, we close the box and use the black box testing. ]
strong => [ Following are the differences among white box, black box, and gray box testing are: ]
th => [ Black box testing ]
th => [ Gray box testing ]
th => [ White box testing ]
td => [ Black box testing does not need the implementation knowledge of a program. ]
td => [ Gray box testing knows the limited knowledge of an internal program. ]
td => [ In white box testing, implementation details of a program are fully required. ]
td => [ It has a low granularity. ]
td => [ It has a medium granularity. ]
td => [ It has a high granularity. ]
td => [ It is also known as opaque box testing, closed box testing, input-output testing, data-driven testing, behavioral testing and functional testing. ]
td => [ It is also known as translucent testing. ]
td => [ It is also known as glass box testing, clear box testing. ]
td => [ It is a user acceptance testing, i.e., it is done by end users. ]
td => [ It is also a user acceptance testing. ]
td => [ Testers and programmers mainly do it. ]
td => [ Test cases are made by the functional specifications as internal details are not known. ]
td => [ Test cases are made by the internal details of a program. ]
td => [ Test cases are made by the internal details of a program. ]
h3 => [ 3)What are the advantages of designing tests early in the life cycle? ]
p => [ Designing tests early in the life cycle prevent defects from being in the main code. ]
h3 => [ 4) What are the types of defects? ]
p => [ There are three types of defects: Wrong, missing, and extra. ]
p => [  Wrong:  These defects are occurred due to requirements have been implemented incorrectly. ]
p => [  Missing:  It is used to specify the missing things, i.e., a specification was not implemented, or the requirement of the customer was not appropriately noted. ]
p => [  Extra:  This is an extra facility incorporated into the product that was not given by the end customer. It is always a variance from the specification but may be an attribute that was desired by the customer. However, it is considered as a defect because of the variance from the user requirements. ]
h3 => [ 5) What is exploratory testing? ]
p => [ Simultaneous test design and execution against an application is called exploratory testing. In this testing, the tester uses his domain knowledge and testing experience to predict where and under what conditions the system might behave unexpectedly. ]
h3 => [ 6) When should exploratory testing be performed? ]
p => [ Exploratory testing is performed as a final check before the software is released. It is a complementary activity to automated regression testing. ]
h3 => [ 7) What are the advantages of designing tests early in the life cycle? ]
p => [ It helps you to prevent defects in the code. ]
h3 => [ 8) Tell me about the risk-based testing. ]
p => [ The risk-based testing is a testing strategy that is based on prioritizing tests by risks. It is based on a detailed risk analysis approach which categorizes the risks by their priority. Highest priority risks are resolved first. ]
h3 => [ 9) What is acceptance testing? ]
p => [ Acceptance testing is done to enable a user/customer to determine whether to accept a software product. It also validates whether the software follows a set of agreed acceptance criteria. In this level, the system is tested for the user acceptability. ]
strong => [ Types of acceptance testing are: ]
strong => [ User acceptance testing ]
strong => [ Operational acceptance testing ]
strong => [ Contract and regulation acceptance testing ]
strong => [ Alpha and beta testing ]
h3 => [ 10) What is accessibility testing? ]
p => [ Accessibility testing is used to verify whether a software product is accessible to the people having disabilities (deaf, blind, mentally disabled etc.). ]
h3 => [ 11) What is Adhoc testing? ]
p => [ Ad-hoc testing is a testing phase where the tester tries to 'break' the system by randomly trying the system's functionality. ]
h3 => [ 12) What is Agile testing? ]
p => [ Agile testing is a testing practice that uses agile methodologies i.e. follow test-first design paradigm. ]
h3 => [ 13) What is API (Application Programming Interface)? ]
p => [ Application Programming Interface is a formalized set of software calls and routines that can be referenced by an application program to access supporting system or network services. ]
h3 => [ 14) What do you mean by automated testing? ]
p => [ Testing by using software tools which execute test without manual intervention is known as automated testing. Automated testing can be used in GUI, performance, API, etc. ]
h3 => [ 15) What is Bottom-up testing? ]
p => [ The Bottom-up testing is a testing approach which follows integration testing where the lowest level components are tested first, after that the higher level components are tested. The process is repeated until the testing of the top-level component. ]
h3 => [ 16) What is Baseline Testing? ]
p => [ In Baseline testing, a set of tests is run to capture performance information. Baseline testing improves the performance and capabilities of the application by using the information collected and make the changes in the application. Baseline compares the present performance of the application with its previous performance. ]
h3 => [ 17) What is Benchmark Testing? ]
p => [ Benchmarking testing is the process of comparing application performance with respect to the industry standard given by some other organization. ]
p => [ It is a standard testing which specifies where our application stands with respect to others. ]
h3 => [ 18) Which types are testing are important for web testing? ]
p => [ There are two types of testing which are very important for web testing: ]
strong => [ Performance testing ]
strong => [ Security testing ]
h3 => [ 19) What is the difference between web application and desktop application in the scenario of testing? ]
p => [ The difference between a web application and desktop application is that a web application is open to the world with potentially many users accessing the application simultaneously at various times, so load testing and stress testing are important. Web applications are also prone to all forms of attacks, mostly DDOS, so security testing is also very important in the case of web applications. ]
h3 => [ 20) What is the difference between verification and validation? ]
p => [ Difference between verification and validation: ]
th => [ Verification ]
th => [ Validation ]
td => [ Verification is Static Testing. ]
td => [ Validation is Dynamic Testing. ]
td => [ Verification occurs before Validation. ]
td => [ Validation occurs after Verification. ]
td => [ Verification evaluates plans, document, requirements and specification. ]
td => [ Validation evaluates products. ]
td => [ In verification, inputs are the checklist, issues list, walkthroughs, and inspection. ]
td => [ Invalidation testing, the actual product is tested. ]
td => [ Verification output is a set of document, plans, specification and requirement documents. ]
td => [ Invalidation actual product is output. ]
h3 => [ 21) What is the difference between Retesting and Regression Testing? ]
p => [ A list of differences between Retesting and Regression Testing: ]
th => [ Regression ]
th => [ Retesting ]
td => [ Regression is a type of software testing that checks the code change does not affect the current features and functions of an application. ]
td => [ Retesting is the process of testing that checks the test cases which were failed in the final execution. ]
td => [ The main purpose of regression testing is that the changes made to the code should not affect the existing functionalities. ]
td => [ Retesting is applied on the defect fixes. ]
td => [ Defect verification is not an element of Regression testing. ]
td => [ Defect verification is an element of regression testing. ]
td => [ Automation can be performed for regression testing while manual testing could be expensive and time-consuming. ]
td => [ Automation cannot be performed for Retesting. ]
td => [ Regression testing is also known as generic testing. ]
td => [ Retesting is also known as planned testing. ]
td => [ Regression testing concern with executing test cases that was passed in earlier builds.	Retesting concern with executing those test cases that are failed earlier. ]
td => [ Regression testing can be performed in parallel with the retesting.	Priority of retesting is higher than the regression testing. ]
h3 => [ 22) What is the difference between preventative and reactive approaches to testing?  ]
p => [ Preventative tests are designed earlier, and reactive tests are designed after the software has been produced. ]
h3 => [ 23) What is the purpose of exit criteria? ]
p => [ The exit criteria are used to define the completion of the test level. ]
h3 => [ 24) Why is the decision table testing used? ]
p => [ A decision table consists of inputs in a column with the outputs in the same column but below the inputs. ]
p => [ The decision table testing is used for testing systems for which the specification takes the form of rules or cause-effect combination. The reminders you get in the table explore combinations of inputs to define the output produced. ]
h3 => [ 25) What is alpha and beta testing? ]
p => [ These are the key differences between alpha and beta testing: ]
th => [ No. ]
th => [ Alpha Testing ]
th => [ Beta Testing ]
td => [ 1) ]
td => [ It is always done by developers at the software development site. ]
td => [ It is always performed by customers at their site. ]
td => [ 2) ]
td => [ It is also performed by Independent testing team ]
td => [ It is not be performed by Independent testing team ]
td => [ 3) ]
td => [ It is not open to the market and public. ]
td => [ It is open to the market and public. ]
td => [ 4) ]
td => [ It is always performed in a virtual environment. ]
td => [ It is always performed in a real-time environment. ]
td => [ 5) ]
td => [ It is used for software applications and projects. ]
td => [ It is used for software products. ]
td => [ 6) ]
td => [ It follows the category of both white box testing and Black Box Testing. ]
td => [ It is only the kind of Black Box Testing. ]
td => [ 7) ]
td => [ It is not known by any other name. ]
td => [ It is also known as field testing. ]
h3 => [ 26) What is Random/Monkey Testing? ]
p => [ Random testing is also known as monkey testing. In this testing, data is generated randomly often using a tool. The data is generated either using a tool or some automated mechanism. ]
p => [ Random testing has some limitations: ]
li => [ Most of the random tests are redundant and unrealistic. ]
li => [ It needs more time to analyze results. ]
li => [ It is not possible to recreate the test if you do not record what data was used for testing. ]
h3 => [ 27) What is the negative and positive testing? ]
p => [  Negative Testing:  When you put an invalid input and receive errors is known as negative testing. ]
p => [  Positive Testing:  When you put in the valid input and expect some actions that are completed according to the specification is known as positive testing. ]
h3 => [ 28) What is the benefit of test independence? ]
p => [ Test independence is very useful because it avoids author bias in defining effective tests. ]
h3 => [ 29) What is the boundary value analysis/testing? ]
p => [ In boundary value analysis/testing, we only test the exact boundaries rather than hitting in the middle. For example: If there is a bank application where you can withdraw a maximum of 25000 and a minimum of 100. So in boundary value testing we only test above the max and below the max. This covers all scenarios. ]
p => [ The following figure shows the boundary value testing for the above-discussed bank application.TC1 and TC2 are sufficient to test all conditions for the bank. TC3 and TC4 are duplicate/redundant test cases which do not add any value to the testing. So by applying proper boundary value fundamentals, we can avoid duplicate test cases, which do not add value to the testing. ]
h3 => [ 30) How would you test the login feature of a web application? ]
p => [ There are many ways to test the login feature of a web application: ]
li => [ Sign in with valid login, Close browser and reopen and see whether you are still logged in or not. ]
li => [ Sign in, then log out and then go back to the login page to see if you are truly logged out. ]
li => [ Log in, then go back to the same page, do you see the login screen again? ]
li => [ Session management is important. You must focus on how do we keep track of logged in users, is it via cookies or web sessions? ]
li => [ Sign in from one browser, open another browser to see if you need to sign in again? ]
li => [ Log in, change the password, and then log out, then see if you can log in again with the old password. ]
h3 => [ 31) What are the types of performance testing? ]
p => [  Performance testing : Performance testing is a testing technique which determines the performance of the system such as speed, scalability, and stability under various load conditions. The product undergoes the performance testing before it gets live in the market. ]
strong => [ Types of software testing are: ]
strong => [ 1. Load testing: ]
li => [ Load testing is a testing technique in which system is tested with an increasing load until it reaches the threshold value. ]
h4 => [ Note: An increasing load means the increasing the number of users. ]
li => [ The main purpose of load testing is to check the response time of the system with an increasing amount of load. ]
li => [ Load testing is non-functional testing means that the only non-functional requirements are tested. ]
li => [ Load testing is performed to make sure that the system can withstand a heavy load ]
strong => [ 2. Stress testing: ]
li => [ Stress testing is a testing technique to check the system when hardware resources are not enough such as CPU, memory, disk space, etc. ]
li => [ In case of stress testing, software is tested when the system is loaded with the number of processes and the hardware resources are less. ]
li => [ The main purpose of stress testing is to check the failure of the system and to determine how to recover from this failure is known as recoverability. ]
li => [ Stress testing is non-functional testing means that the only non-functional requirements are tested. ]
strong => [ 3. Spike testing: ]
li => [ Spike testing is a subset of load testing. This type of testing checks the instability of the application when the load is varied. ]
li => [ The first case is not to allow the number of users so that the system will not suffer heavy load. ]
li => [ The second case is to provide warnings to the extra joiners, and this would slow down the response time. ]
strong => [ 4. Endurance testing: ]
li => [ Endurance testing is a subset of load testing. This type of testing checks the behavior of the system. ]
li => [ Endurance testing is non-functional testing means that the only non-functional requirements are tested. ]
li => [ Endurance testing is also known as Soak testing. ]
li => [ Endurance testing checks the issues such as memory leak. A memory leak occurs when the program does not release its allocated memory after its use. Sometimes the application does not release its memory even after its use and this unusable memory cause memory leak. This causes an issue when the application runs for a long duration. ]
li => [ Memory leaks occurred due to an application. ]
li => [ Memory leaks occurred due to a database connection. ]
li => [ Memory leaks occurred due to a third party software. ]
strong => [ 5. Volume testing: ]
li => [ Volume testing is a testing technique in which the system is tested when the volume of data is increased. ]
li => [ Volume testing is also known as flood testing. ]
li => [ Volume testing is non-functional testing means that the only non-functional requirements are tested. ]
li => [ For example: If we want to apply the volume testing then we need to expand the database size, i.e., adding more data into the database table and then perform the test. ]
strong => [ 6. Scalability testing ]
li => [ Scalability testing is a testing technique that ensures that the system works well in proportion to the growing demands of the end users. ]
li => [ Response time ]
li => [ Throughput ]
li => [ Number of users required for performance test ]
li => [ Threshold load ]
li => [ CPU usage ]
li => [ Memory usage ]
li => [ Network usage ]
h3 => [ 32) What is the difference between functional and non-functional testing? ]
th => [ Basis of comparison ]
th => [ Functional testing ]
th => [ Non-functional testing ]
td => [ Description ]
td => [ Functional testing is a testing technique which checks that function of the application works under the requirement specification. ]
td => [ Non-functional testing checks all the non-functional aspects such as performance, usability, reliability, etc. ]
td => [ Execution ]
td => [ Functional testing is implemented before non-functional testing. ]
td => [ Non-functional testing is performed after functional testing. ]
td => [ Focus area ]
td => [ It depends on the customer requirements. ]
td => [ It depends on the customer expectations. ]
td => [ Requirement ]
td => [ Functional requirements can be easily defined. ]
td => [ Non-functional requirements cannot be easily defined. ]
td => [ Manual testing ]
td => [ Functional testing can be performed by manual testing. ]
td => [ Non-functional testing cannot be performed by manual testing. ]
td => [ Testing types ]
li => [ Unit testing ]
li => [ Acceptance testing ]
li => [ Integration testing ]
li => [ System testing ]
li => [ Performance testing ]
li => [ Load testing ]
li => [ Stress testing ]
li => [ Volume testing ]
li => [ Security testing ]
li => [ Installation testing ]
li => [ Recovery testing ]
h3 => [ 33) What is the difference between static and dynamic testing? ]
th => [ Static testing ]
th => [ Dynamic testing ]
td => [ Static testing is a white box testing technique which is done at the initial stage of the software development lifecycle. ]
td => [ Dynamic testing is a testing process which is done at the later stage of the software development lifecycle. ]
td => [ Static testing is performed before the code deployment. ]
td => [ Dynamic testing is performed after the code deployment. ]
td => [ It is implemented at the verification stage. ]
td => [ It is implemented at the validation stage. ]
td => [ Execution of code is not done during this type of testing. ]
td => [ Execution of code is necessary for the dynamic testing. ]
td => [ In the case of static testing, the checklist is made for the testing process. ]
td => [ In the case of dynamic testing, test cases are executed. ]
h3 => [ 34) What is the difference between negative and positive testing? ]
th => [ Positive testing ]
th => [ Negative testing ]
td => [ Positive testing means testing the application by providing valid data. ]
td => [ Negative testing means testing the application by providing the invalid data. ]
td => [ In case of positive testing, tester always checks the application for a valid set of values. ]
td => [ In the case of negative testing, tester always checks the application for the invalid set of values. ]
td => [ Positive testing is done by considering the positive point of view for example: checking the first name field by providing the value such as "Akshay". ]
td => [ Negative testing is done by considering the negative point of view for example: checking the first name field by providing the value such as "Akshay123". ]
td => [ It verifies the known set of test conditions. ]
td => [ It verifies the unknown set of conditions. ]
td => [ The positive testing checks the behavior of the system by providing the valid set of data. ]
td => [ The negative testing tests the behavior of the system by providing the invalid set of data. ]
td => [ The main purpose of the positive testing is to prove that the project works well according to the customer requirements. ]
td => [ The main purpose of the negative testing is to break the project by providing the invalid set of data. ]
td => [ The positive testing tries to prove that the project meets all the customer requirements. ]
td => [ The negative testing tries to prove that the project does not meet all the customer requirements. ]
h3 => [ 35) What are the different models available in SDLC? ]
p => [ There are various models available in software testing, which are the following: ]
li => [ Waterfall model ]
li => [ Spiral Model ]
li => [ Prototype model ]
li => [ Verification and validation model ]
li => [ Hybrid model ]
li => [ Agile model ]
li => [ Rational unified process model[RUP] ]
li => [ Rapid Application development [RAD] ]
h3 => [ 36) List out the difference between smoke testing and sanity testing and dry run testing? ]
p => [ Following are the differences between smoke, sanity, and dry run testing: ]
th => [ Smoke testing ]
th => [ Sanity testing ]
th => [ Dry-run testing ]
td => [ It is shallow, wide and scripted testing. ]
td => [ It is narrow and deep and unscripted testing ]
td => [ A dry run testing is a process where the effects of a possible failure are internally mitigated. ]
td => [ When the builds come, we will write the automation script and execute the scripts. So it will perform automatically. ]
td => [ It will perform manually. ]
td => [ For Example, An aerospace company may conduct a Dry run of a takeoff using a new aircraft and a runway before the first test flight. ]
td => [ It will take all the essential features and perform high-level testing. ]
td => [ It will take some significant features and perform in-depth testing. ]
h3 => [ 37) How do we test a web application? What are the types of tests we perform on the web application? ]
p => [  To test any web application such as  Yahoo, Gmail , and so on, we will perform the following testing: ]
li => [ Functional testing ]
li => [ Integration testing ]
li => [ System testing ]
li => [ Performance testing ]
li => [ Compatibility testing ( test the application on the various operating systems, multiple browsers, and different version) ]
li => [ Usability testing ( check whether it is user friendly) ]
li => [ Ad-hoc testing ]
li => [ Accessibility testing ]
li => [ Smoke testing ]
li => [ Regression testing ]
li => [ Security testing ]
li => [ Globalization testing ( only if it is developed in different languages) ]
h3 => [ 38) Why do we need to perform compatibility testing? ]
p => [ We might have developed the software in one platform, and the chances are there that users might use it in the different platforms. Hence, it could be possible that they may encounter some bugs and stop using the application, and the business might get affected. Therefore, we will perform one round of Compatibility testing. ]
h3 => [ 39) How many test cases we can write in a day? ]
p => [ We can tell anywhere between 2-5 test cases. ]
li => [ First test case → 1st day, 2nd day. ]
li => [ Second test case → 3rd day, 4th day. ]
li => [ Forth test case → 5th day. ]
li => [ 9-10 test cases → 19th day. ]
p => [ Primarily, we use to write 2-5 test cases, but in future stages we write around 6-7 because, at that time, we have the better product knowledge, we start re-using the test cases, and the experience on the product. ]
h3 => [ 40) How many test cases can we review per day? ]
p => [ It would be around 7 test cases we write so that we can review 7*3=21 test cases. And we can say that 25-30 test case per day. ]
h3 => [ 41) How many test cases can we run in a day? ]
p => [ We can run around 30-55 test cases per day. ]
h4 => [ Note: For these types of questions (39-41), always remember the ratio: x test cases we can write, 3x test cases we can review, and 5x test cases we can execute per day. ]
h3 => [ 42) Does the customer get a 100% bug-free product? ]
li => [ The testing team is not good ]
li => [ Developers are super ]
li => [ Product is old ]
li => [ All of the above ]
p => [  The correct answer is  testing team is not good  because sometimes the fundamentals of software testing define that no product has zero bugs. ]
h3 => [ 43) How to track the bug manually and with the help of automation? ]
p => [ We can track the bug manually as: ]
li => [ Identify the bug. ]
li => [ Make sure that it is not duplicate (that is, check it in bug repository). ]
li => [ Prepare a bug report. ]
li => [ Store it in bug repository. ]
li => [ Send it to the development team. ]
li => [ Manage the bug life cycle (i.e., keep modifying the status). ]
p => [  Tracking the bug with the help of  automation  i.e., bug tracking tool: ]
p => [ We have various bug tracking tools available in the market, such as: ]
li => [ Jira ]
li => [ Bugzilla ]
li => [ Mantis ]
li => [ Telelogic ]
li => [ Rational Clear Quest ]
li => [ Bug_track ]
li => [ Quality center ( it is a test management tool, a part of it is used to track the bugs) ]
h4 => [ Note: Here, we have two categories of tools: ]
p => [  A product based : In the product based companies, they will use only one bug tracking tool. ]
p => [  Service-based : In service-based companies, they have many projects of different customers, and every project will have different bug tracking tools. ]
h3 => [ 44) Why does an application have bugs? ]
p => [ The software can have a bug for the following reasons: ]
li => [ Software complexity ]
li => [ Programming errors ]
li => [ If no communications are happening between the customer and the company, i.e., an application should or should not perform according to the software's needs. ]
li => [ Modification in requirements ]
li => [ Time pressure. ]
h3 => [ 45) When we perform testing? ]
p => [ We will perform testing whenever we need to check all requirements are executed correctly or not, and to make sure that we are delivering the right quality product. ]
h3 => [ 46) When do we stop the testing? ]
p => [ We can stop testing whenever we have the following: ]
li => [ Once the functionality of the application is stable. ]
li => [ When the time is less, then we test the necessary features, and we stop it. ]
li => [ The client's budget. ]
li => [ When the essential feature itself is not working correctly. ]
h3 => [ 47) For which and all types of testing do we write test cases? ]
p => [ We can write test cases for the following types of testing: ]
th => [ Different types of testing
 ]
td => [ Test cases
 ]
strong => [ Smoke testing ]
td => [ In this, we will write only standard features; thus, we can pull out some test cases that have all the necessary functions. Therefore, we do not have to write a test case for smoke testing. ]
strong => [ Functional/unit testing ]
td => [ Yes, we write the test case for unit testing. ]
strong => [ Integration testing ]
td => [ Yes, we write the test case for integration testing. ]
strong => [ System testing ]
td => [ Yes, we write the test case for system testing. ]
strong => [ Acceptance testing ]
td => [ Yes, but here the customer may write the test case. ]
strong => [ Compatibility testing ]
td => [ In this, we don't have to write the test case because the same test cases as above are used for testing on different platforms. ]
strong => [ Adhoc testing ]
td => [ We don't write the test case for the Adhoc testing because there are some random scenarios or the ideas, which we used at the time of Adhoc time. Though, if we identify the critical bug, then we convert that scenario into a test case. ]
strong => [ Performance testing ]
td => [ We might not write the test cases because we will perform this testing with the help of performance tools. ]
strong => [ Usability testing ]
td => [ In this, we use the regular checklist; therefore, we don't write the test case because here we are only testing the look and feel of the application. ]
strong => [ Accessibility testing ]
td => [ In accessibility testing, we also use the checklist. ]
strong => [ Reliability testing ]
td => [ Here, we don't write the manual test cases as we are using the automation tool to perform reliability testing. ]
strong => [ Regression testing ]
td => [ Yes, we write the test cases for functional, integration, and system testing. ]
strong => [ Recovery testing ]
td => [ Yes, we write the test cases for recovery testing, and also check how the product recovers from the crash. ]
strong => [ Security testing ]
td => [ Yes, we write the test case for security testing. ]
strong => [ Globalization testing: ]
strong => [ Localization testing ]
strong => [ Internationalization testing ]
h3 => [ 48) What is the difference between the traceability matrix and the test case review process? ]
th => [ Traceability matrix ]
th => [ Test case review ]
td => [ In this, we will make sure that each requirement has got at least one test case. ]
td => [ In this, we will check whether all the scenarios are covered for the particular requirements. ]
h3 => [ 49) What is the difference between use case and test case? ]
p => [ Following are the significant differences between the use case and the test case: ]
th => [ Test case ]
th => [ Use Case ]
td => [ It is a document describing the input, action, and expected response to control whether the application is working fine based on the customer requirements. ]
td => [ It is a detailed description of Customer Requirements. ]
td => [ It is derived from test scenarios, Use cases, and the SRS. ]
td => [ It is derived from BRS/SRS. ]
td => [ While developing test cases, we can also identify loopholes in the specifications. ]
td => [ A business analyst or QA Lead prepares it. ]
h3 => [ 50) How to test a pen? ]
p => [ We can perform both manual and automation testing. First, we will see how we perform manual testing: ]
th => [ Different types of testing ]
th => [ Scenario ]
strong => [ Smoke testing ]
td => [ Checks that basic functionality is written or not. ]
strong => [ Functional/unit testing ]
td => [ Check that the Refill, pen body, pen cap, and pen size as per the requirement. ]
strong => [ Integration testing ]
td => [ Combine pen and cap and integrate other different sizes and see whether they work fine. ]
strong => [ Compatibility testing ]
td => [ Various surfaces, multiple environments, weather conditions, and keep it in oven and then write, keep it in the freezer and write, try and write on water. ]
strong => [ Adhoc testing ]
td => [ Throw the pen down and start writing, keep it vertically up and write, write on the wall. ]
strong => [ Performance testing ]
td => [ Test the writing speed of the pen. ]
strong => [ Usability testing ]
td => [ Check whether the pen is user friendly or not, whether we can write it for more extended periods smoothly. ]
strong => [ Accessibility testing ]
td => [ Handicapped people use them. ]
strong => [ Reliability testing ]
td => [ Drop it down and write, and continuously write and see whether it leaks or not ]
strong => [ Recovery testing ]
td => [ Throw it down and write. ]
strong => [ Globalization testing ]
strong => [ Localization testing ]
td => [ Price should be standard, expiry date format. ]
strong => [ Internationalize testing ]
td => [ Check whether the print on the pen is as per the country language. ]
p => [ Now, we will see how we perform automation testing on a pen: ]
p => [ For this take a roller, now put some sheets of paper on the roller, then connects the pen to the motor and switch on the motor. The pen starts writing on the paper. Once the pen has stopped writing, now observe the number of lines that it has written on each page, length of each track, and multiplying all this, so we can get for how many kilometers the pen can write. ]
span => [ Job/HR Interview Questions ]
span => [ Database Interview Questions ]
span => [ PL/SQL Interview Questions ]
span => [ SQL Interview Questions ]
span => [ Oracle Interview Questions ]
span => [ Android Interview Questions ]
span => [ SQL Server Interview Questions ]
span => [ MySQL Interview Questions ]
a => [ Java Basics Interview Questions ]
a => [ Java OOPs Interview Questions ]
a => [ Java Multithreading Questions ]
a => [ Java String &amp; Exception Questions ]
a => [ Java Collection Interview Questions ]
a => [ JDBC Interview Questions ]
a => [ Servlet Interview Questions ]
a => [ JSP Interview Questions ]
span => [ Spring Interview Questions ]
span => [ Hibernate Interview Questions ]
h2 => [ You may also like: ]
a => [ Java Interview Questions ]
a => [ SQL Interview Questions ]
a => [ Python Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ Angular Interview Questions ]
a => [ Selenium Interview Questions ]
a => [ Spring Boot Interview Questions ]
a => [ HR Interview Questions ]
a => [ C Programming Interview Questions ]
a => [ C++ Interview Questions ]
a => [ Data Structure Interview Questions ]
a => [ DBMS Interview Questions ]
a => [ HTML Interview Questions ]
a => [ IAS Interview Questions ]
a => [ Manual Testing Interview Questions ]
a => [ OOPs Interview Questions ]
a => [ .Net Interview Questions ]
a => [ C# Interview Questions ]
a => [ ReactJS Interview Questions ]
a => [ Networking Interview Questions ]
a => [ PHP Interview Questions ]
a => [ CSS Interview Questions ]
a => [ Node.js Interview Questions ]
a => [ Spring Interview Questions ]
a => [ Hibernate Interview Questions ]
a => [ AWS Interview Questions ]
a => [ Accounting Interview Questions ]
h2 => [ Learn Latest Tutorials ]
p => [ Splunk ]
p => [ SPSS ]
p => [ Swagger ]
p => [ Transact-SQL ]
p => [ Tumblr ]
p => [ ReactJS ]
p => [ Regex ]
p => [ Reinforcement Learning ]
p => [ R Programming ]
p => [ RxJS ]
p => [ React Native ]
p => [ Python Design Patterns ]
p => [ Python Pillow ]
p => [ Python Turtle ]
p => [ Keras ]
h2 => [ Preparation ]
p => [ Aptitude ]
p => [ Reasoning ]
p => [ Verbal Ability ]
p => [ Interview Questions ]
p => [ Company Questions ]
h2 => [ Trending Technologies ]
p => [ Artificial Intelligence ]
p => [ AWS ]
p => [ Selenium ]
p => [ Cloud Computing ]
p => [ Hadoop ]
p => [ ReactJS ]
p => [ Data Science ]
p => [ Angular 7 ]
p => [ Blockchain ]
p => [ Git ]
p => [ Machine Learning ]
p => [ DevOps ]
h2 => [ B.Tech / MCA ]
p => [ DBMS ]
p => [ Data Structures ]
p => [ DAA ]
p => [ Operating System ]
p => [ Computer Network ]
p => [ Compiler Design ]
p => [ Computer Organization ]
p => [ Discrete Mathematics ]
p => [ Ethical Hacking ]
p => [ Computer Graphics ]
p => [ Software Engineering ]
p => [ Web Technology ]
p => [ Cyber Security ]
p => [ Automata ]
p => [ C Programming ]
p => [ C++ ]
p => [ Java ]
p => [ .Net ]
p => [ Python ]
p => [ Programs ]
p => [ Control System ]
p => [ Data Mining ]
p => [ Data Warehouse ]
