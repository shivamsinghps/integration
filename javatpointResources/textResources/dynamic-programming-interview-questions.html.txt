
div => [ 
 ]
a => [ next → ]
a => [ ← prev ]
h1 => [ Dynamic Programming interview questions ]
h3 => [ 1) What is Dynamic programming? ]
p => [ The idea behind using the dynamic programming is that we have solved a problem with a given input then save the result for the future reference to avoid solving the same problem again and again. The dynamic programming was developed by Richard Bellman. ]
p => [ The dynamic programming in a dynamic programming world is a powerful technique that allows one to solve different types of problems in polynomial time for which a na�ve approach would take an exponential time. ]
p => [ For example, if we take the example of Fibonacci series in which each number is the sum of the next two preceding numbers. The Fibonacci numbers are 0, 1, 1, 2, 3, 5, 8, and so on. If we are asked to calculate the nth Fibonacci number. We can calculate this with the following recurrence formula: ]
strong => [ Fib(n) = n if n&lt;2 ]
strong => [ fib(n-1) + fib(n-2) otherwise ]
p => [ In the case of naive approach, the implementation of Fibonacci function has the time complexity of O(2^n) time where the dynamic programming approach solution can achieve the same with only O(n) time. ]
h3 => [ 2) What are the characteristics of dynamic programming? ]
p => [ The following are the characteristics of dynamic programming: ]
strong => [ Optimal Substructures: ]
strong => [ Overlapping subproblems: ]
h3 => [ 3 What are the dynamic programming methods? ]
p => [ We can use the following two methods to optimize the problem: ]
li => [ Top-down approach ]
li => [ Bottom-up approach ]
strong => [ Top-down approach ]
li => [ The top-down approach is the technique to solve the larger problems by recursively finding the solution to the smaller problems. ]
li => [ When the solution to the subproblem is found, then the result to the problem is stored or cache so that we do not need to calculate the result many times. Instead of calculating the result, we just have to return the cached result. ]
li => [ The method of storing the result of already solved subproblems is known as a memorization. ]
strong => [ Let's understand this approach with memorization and without memorization. ]
strong => [ Without memoization ]
p => [  In the above code, we have used the recursive approach to find out the Fibonacci series. When the value of 'n' increases, the function calls will also increase, and computations will also increase. In this case, the time complexity increases exponentially, and it becomes 2 n . ]
strong => [ With memorization ]
p => [ In the above code, we have declared an array named as 'memo'. We have declared this array so that we can store the result of the subproblem. This solves the problem of calculating the solution of already calculate subproblem. ]
h3 => [ 4) What are the applications of dynamic programming? ]
strong => [ The following is the list of applications of a dynamic programming: ]
strong => [ Google maps: ]
strong => [ Longest common subsequence: ]
strong => [ Longest increasing subsequence problem: ]
strong => [ Knapsack problem: ]
li => [ First, we will find the solution to the subproblems. ]
li => [ Then, we will find the formula to build the solution for the subproblem. ]
li => [ In this step, we will create a table that will store the solutions of subproblems. Calculate the solution of the subproblems and stores the solution in a table. ]
li => [ Once all the subproblems are solved, we will find the solution to the original problem. ]
h3 => [ 5) What are the differences between the top-down approach and the bottom-up approach? ]
strong => [ The following is the list of differences between the top-down approach and the bottom-up approach: ]
th => [ Top-down approach ]
th => [ Bottom-up approach ]
td => [ It is an approach that is used to break the problem into subproblems. ]
td => [ It finds the solution to the smaller problems and then integrate the solution of all the subproblems to achieve the complete solution. ]
td => [ This approach is mainly used by the structured programming languages such as COBOL, Fortran, C, etc. ]
td => [ This approach is mainly used by the object-oriented programming languages such as C++, C#, Python, etc. ]
td => [ It contains redundancy because each subprogram is programmed separately.  ]
td => [ It minimizes the redundancy by using the concept of data hiding and encapsulation. ]
td => [ Communication is very less between the modules. ]
td => [ There exists a communication between the modules. ]
td => [ The top-down approach is used in debugging, module documentation, etc. ]
td => [ It is mainly used in testing. ]
td => [ The decomposition takes place in top-down approach. ]
td => [ The composition takes place in the bottom-up approach. ]
td => [ The access is faster because all the state values are directly accessed from the table. ]
td => [ The access is slower due to recursive calls and return statements. ]
h3 => [ 6) What are the differences between the dynamic programming and greedy approach? ]
strong => [ The following is the list of differences between the dynamic programming and greedy approach: ]
th => [ Dynamic programming ]
th => [ Greedy approach ]
td => [ Dynamic programming will consider all the possible cases and select the best option to obtain the optimal solution. ]
td => [ This approach does not guarantee the optimal solution. ]
td => [ It requires table to store the already solved subproblems, and this increase the memory complexity. ]
td => [ It is quite efficient in memory utilization as it does not have to look back at memory for the data retrieval. ]
td => [ Dynamic methods are mainly slower. ]
td => [ Greedy methods are mainly faster. ]
td => [ It chooses the optimal solution of the subproblems so overlapping problems can be handled. ]
td => [ Overlapping subproblems cannot be handled. ]
td => [ It is highly reliable. ]
td => [ It is less reliable. ]
td => [ Example is 0/1 knapsack ]
td => [ Fractional knapsack, shortest path ]
td => [ It does not contain a special set of feasible set of solution. ]
td => [ It contains a particular set of feasible set of solutions. ]
h3 => [ 7) What are the differences between the dynamic programming and divide and conquer approach? ]
strong => [ The following is the list of differences between the dynamic programming and divide and conquer approach: ]
th => [ Dynamic programming ]
th => [ Divide and conquer approach ]
td => [ Dynamic programming approach is non-recursive. ]
td => [ Divide and conquer approach is recursive. ]
td => [ In dynamic programming, subproblems are dependent of each other. ]
td => [ In divide and conquer approach, subproblems are not dependent of each other. ]
td => [ In dynamic programming method, it uses the solution of the previously solved subproblem so it is less time-consuming. ]
td => [ In divide and conquer method, each subproblem is solved independently so it is more time consuming. ]
td => [ It is more efficient. ]
td => [ It is less efficient than the dynamic programming approach. ]
td => [ Matrix chain multiplication and optimal binary search tree use the dynamic programming approach. ]
td => [ Merge sort, quick sort and binary search use the divide and conquer technique. ]
td => [ It uses the result of all the subproblems to achieve the optimum solution of the main problem. ]
td => [ It combines the solutions of all the subproblems to obtain the solution of the main problem. ]
h3 => [ 8) How dynamic programming is different from the memoization and recursion? ]
p => [ Recursion is a process of calling the function itself again and again. Memoization is a technique of storing the solution of solved sub problems. Dynamic programming is a technique of solving the recursions by storing the solutions of already sub problems. ]
h3 => [ 9) What is the longest palindromic sequence? ]
p => [ The longest palindromic sequence is the problem where the sequence is given and we need to find the length of the longest palindromic subsequence. A subsequence is a sequence derived from the main sequence by taking some or all the elements from the sequence without changing the order of the elements. Here, the palindromic subsequence means that the elements appear same from both the directions, i.e., forward and backward direction. ]
strong => [ Let's understand this problem through an example. ]
p => [ Suppose we have an input "bbbab". ]
p => [ The following are the palindromic subsequences that can be made from the above sequence: ]
p => [ bbbb ]
p => [ bbb ]
p => [ bab ]
p => [ Since the subsequence "bbbb" contains a greater number of characters, i.e., 4; therefore, the longest palindromic subsequence is "bbbb". ]
h3 => [ 10) Problem statement: ]
strong => [ Given two strings s1 and s2. We have to find the longest common subsequence between the strings s1 and s2. ]
p => [ For example: ]
p => [ S1: "ACBEA" ]
p => [ S2: "ADCA" ]
p => [ To start with this problem, let's match the strings character by character from the ends of the strings. ]
p => [ LCS("ACBEA", "ADCA") = 1 + LCS("ACBE", "ADC") ]
p => [ Since the character 'A' is common in the both the strings so we trim out the character 'A' from both the strings. We put 1 plus LCS of "ACBE" and "ADC". So, when the characters match, we trim that matched character and find out the LCS of the remaining strings. We put 1 because both the characters are matched. ]
p => [ LCS("ACBE", "ADC") = max(LCS(ACB, ADC), LCS(ACBE, AD)) ]
p => [ In the above case, both the characters, i.e., 'E' and 'C' are different. So, first we leave the character from the string ACBE then we compute the LCS. Then, we remove the character from the string ADC. At the end, we consider the maximum of the above two LCSs. ]
p => [ Here we have followed two rules which are given below: ]
li => [ If the characters are matched then we add the 1 and remove the matched characters. ]
li => [ If the characters are not matched then we leave the character and compute the max of the LCSs. ]
p => [ The above approach can be implemented either recursively or using dynamic programming approach. Since recursive approach includes lots of comparisons that leads to the exponential complexity, so it is better to use a dynamic programming approach. ]
strong => [ We consider the following tables: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ C ]
td => [ B ]
td => [ E ]
td => [ A ]
strong => [ Pointer table ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ C ]
td => [ B ]
td => [ E ]
td => [ A ]
p => [ The above is a pointer table where we keep the movements of the matching table. We will use this pointer table to generate the LCS of strings. ]
strong => [ The following are the rules that we use here: ]
strong => [ Last chars match: ]
strong => [ Last chars mismatch: ]
strong => [ Let's start working on these matrices through the initialization. ]
p => [ First, we initialize both the matrices with zero. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now we start with a first row. Since 'A' of both the strings are matched, so add 1 in the first table. We are trimming the character from both the strings so we can pick any of the strings either s1 or s2. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
strong => [ Trimming 'D' character ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ 0 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ In the above case, we increment the count and move ahead. Now the strings which are into consideration are A and AD. Since both the characters, i.e., A and D do not match from both the strings so we can trim only one of the strings. If we trim A from the string s1 then we get an empty string and then we compare A and D in s2; the LCS of empty string and AD would be zero. If we trim D from the string s2 then the LCS of A, and AD would be 1 which is the LCS of A and A. ]
p => [  Since we are trimming character 'D' from the string s2, so we will add string s1 in column D in the pointer table. Here we are applying the rule that if we are trimming only one character at a time then if we trim s1 then we put s2 and if we trim s2 then we put s1 in the pointer table. If we are trimming both the characters then we can trim either  s1  or  s2. ]
strong => [ Trimming 'C' character ]
p => [ Now, A and C are not matched so we increment a counter shown as below. Since we are trimming the character C from the string s2 so we add s2 under the column C in the pointer table. We move ahead to the column A. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ 0 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
strong => [ Trimming 'A' character ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ In this case, A characters of both the strings are matched so we increment the counter shown as below. Here we are trimming the characters from both the strings, so we can add either s1 or s2. Once the counter is incremented, we move down. ]
p => [  Now the strings come into consideration are  AC  and  A.  If we trim A from the string s2 then we get an empty string; the LCS of empty string and AC would be zero. If we trim C from the string s1 then the LCS of A and AC would be equal to 1 shown as below. Once the counter is incremented, we move ahead. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are AC and AD. In this case, we can trim either C or D. If we trim C then the LCS of A and AD is 1 and if we trim D then the LCS of AC and A is 1, so in both the case, the value of LCS is 1. Therefore, we can trim any of these strings, i.e., C and D. Suppose we remove the string C then the LCS of A and AD is 1 so we put 1 and s2 in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are AC and ADC. Since both the characters, i.e., C of both the strings are matched, so we have to trim both the strings. The LCS of AC and ADC is now equal to 1 plus LCS of A and AD. Since the LCS of A and AD is equal to 1, so LCS of AC and ADC would be equal to 2. Since we are trimming both the strings so we can add any of the strings in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ 0 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are AC and ADCA. Since both the characters, i.e., C and A of both the strings are different so we can trim either C or A. If we trim A then the LCS of AC and ADC is 2, and if we trim C then the LCS of A and ADCA is 1. We have to consider the maximum LCS. Here, the maximum LCS is 2; therefore, the LCS of AC and ADCA is equal 2. Here, we are trimming the string s2, so we need to add s1 in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The pointer moves down. Now the strings that come into consideration are ACB and A. Since both the characters, i.e., B and A are different so we can trim either B and A. If we trim A then it would lead to an empty string. If we trim B then the LCS of ACB and A is equal to the LCS of AC and A which is 1 shown as below. In this case, we are trimming the s1 string so we have to add s2 in the pointer table. The pointer moves ahead. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are ACB and AD. Since both the characters, i.e., B and D do not match, so we can trim either B or D. If we trim B, then the LCS of AC and AD is 1 and if we trim D, the LCS of ACB and A is 1. In both the cases, the value of LCS is 1 so we can trim either of the strings. The LCS of ACB and AD would be equal to 1 shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are ACB and ADC. Since both the characters, i.e., B and C do not match, so we can trim either B and C. If we trim B, then the LCS of AC and ADC is 2 and if we trim C, then the LCS of ACB, and AD is 1. Since 2&gt;1; therefore, LCS of ACB and ADC is equal to 2. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are ACB and ADCA. Since both the characters, i.e., B and A do not match, so we can trim either B and A. If we trim B then the LCS of AC and ADCA is 2 and if we trim A then the LCS of ACB and ADC is 2. Since both the LCS are same so we can trim any of the strings. The LCS of ACB and ADCA would be 2. ]
p => [ LCS of ACB and ADC is equal to 2. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that come into consideration are ACBE and A. Since both the characters, i.e., E and A are different so we can trim either E or A. If we trim E, then the LCS of ACB and A is 1. If we trim A then we would get an empty string and LCS would become 0. Since 1&gt;0; therefore, the LCS of ACBE and A would be equal to the LCS of ACB and A, i.e., 1. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that come into consideration are ACBE and AD. Since both the characters, i.e., E and D are different so we can trim either E and D. If we trim E, then the LCS of ACB and AD is 1. If we trim D, then the LCS of ACBE and A is 1. Since both the LCS are same so we can trim any of these strings either ACBE or AD. Therefore, the LCS value of ACBE and AD is 1 and any string s1 or s2 can be added in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ Now the strings that come into consideration are ACBE and ADC. Since both the characters, i.e., E and C are different so we can trim either E or C. If we trim E, then the LCS of ACB and ADC is 2. If we trim C, then the LCS of ACBE and AD is 1. Since 2&gt;1; therefore, the LCS of ACBE and AD is equal to the LCS of ACB and ADC which is 2. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that we consider now are ACBE and ADCA. Since both the characters, i.e., E and A are different so we can trim either E or A. If we trim E, then the LCS of ACB and ADCA is 2. If we trim A, then the LCS of ACBE and ADC is 1. Since 2&gt;1; therefore, the LCS of ACBE and ADCA is equal to the LCS OF ACB and ADCA which is 2. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ A ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that we consider now are ACBEA and A. Since both the characters match, i.e., A so we need to trim both the strings. The LCS value of ACBEA and A would be updated as 1 and any of the strings, i.e., s1 or s2 could be added in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ A ]
td => [ s1/s2 ]
td => [ 0 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that we consider now are ACBEA and AD. Since both the characters, i.e., A and D do not match so we can trim either of the strings. If we trim D then the LCS value of ACBEA and A is 1. If we trim A then the LCS value of ACBE and AD is 1. Since the LCS value in both the cases is same, i.e., 1; therefore, the LCS value of ACBEA and AD is equal to 1. We can add any of the strings in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 0 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ A ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ 0 ]
td => [ 0 ]
p => [ The strings that we consider now are ACBEA and ADC. Since both the characters, i.e., A and C are different so we can trim either of the strings. If we trim A, then the LCS value of ACBE and ADC is 2. If we trim C, then the LCS value of ACBEA and AD is 1. Since 2&gt;1; therefore, the LCS value of ACBEA and ADC is equal to the LCS value of ACBE and ADC which is equal to 2. In the case, we are trimming s1 so we will add s2 in the pointer table shown as below: ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 0 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ A ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ 0 ]
p => [ The strings that we consider now are ACBEA and ADCA. Since both the characters, i.e., A of both the strings match, so we have to trim both the strings. Therefore, the LCS of ACBEA and ADCA is equal to (1 plus LCS of ACBE and ADC, i.e., 2) 3. ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ 1 ]
td => [ C ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ B ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ E ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 2 ]
td => [ A ]
td => [ 1 ]
td => [ 1 ]
td => [ 2 ]
td => [ 3 ]
th => [ A ]
th => [ D ]
th => [ C ]
th => [ A ]
td => [ A ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ s1 ]
td => [ s1/s2 ]
td => [ C ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s1/s2 ]
td => [ s1 ]
td => [ B ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ E ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ A ]
td => [ s1/s2 ]
td => [ s2 ]
td => [ s2 ]
td => [ s1/s2 ]
p => [ We conclude that the length of the longest common subsequence is 3. Now we have to determine the subsequence. The following are the rules used to determine the subsequence: ]
li => [ If the pointer table contains s1/s2 strings then we have to go diagonally up. ]
li => [ If the pointer table contains a string s1 then we have to go left. ]
li => [ If the pointer table contains a string s2 then we have to go up. ]
p => [ Since the pointer is pointing to the last row and the last column, and the value is s1/s2. So, the pointer will move diagonally pointing to the string s2 shown as below: ]
p => [ Now the pointer is pointing to the string s2 so pointer will move up and pointing to the string s2 shown as below: ]
p => [ Since the pointer is pointing to the string s2 so pointer will move up and pointing to the string s1/s2 shown as below: ]
p => [ Since the pointer is pointing to the string s1/s2 so pointer will go diagonally up and pointing to the string s1 shown as below: ]
p => [ Since the pointer is pointing to the string s1 will move left and pointing to the string s1/s2 shown as below: ]
p => [ From the above table, we can observe that longest common subsequence is ACA.  ]
h3 => [ 11) What are the pros and cons of memoization or top-down approach? ]
strong => [ Advantages ]
li => [ It is very easy to understand and implement. ]
li => [ It solves the subproblems only when it is required. ]
li => [ It is easy to debug. ]
strong => [ Disadvantages ]
p => [ It uses the recursion technique that occupies more memory in the call stack. Sometimes when the recursion is too deep, the stack overflow condition will occur. ]
p => [ It occupies more memory that degrades the overall performance. ]
h3 => [ 12. Which approach should we consider when choosing between the top-down approach and the bottom-up approach solutions for the same problem? ]
strong => [ The following are the two things that we consider while deciding an algorithm: ]
strong => [ Time complexity: ]
strong => [ Space complexity: ]
strong => [ fibonacci(n)= fibonacci(n-1) + fibonacci(n-2), ]
span => [ Next Topic ]
a => [ # ]
a => [ ← prev ]
a => [ next → ]
h2 => [ You may also like: ]
a => [ Java Interview Questions ]
a => [ SQL Interview Questions ]
a => [ Python Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ Angular Interview Questions ]
a => [ Selenium Interview Questions ]
a => [ Spring Boot Interview Questions ]
a => [ HR Interview Questions ]
a => [ C Programming Interview Questions ]
a => [ C++ Interview Questions ]
a => [ Data Structure Interview Questions ]
a => [ DBMS Interview Questions ]
a => [ HTML Interview Questions ]
a => [ IAS Interview Questions ]
a => [ Manual Testing Interview Questions ]
a => [ OOPs Interview Questions ]
a => [ .Net Interview Questions ]
a => [ C# Interview Questions ]
a => [ ReactJS Interview Questions ]
a => [ Networking Interview Questions ]
a => [ PHP Interview Questions ]
a => [ CSS Interview Questions ]
a => [ Node.js Interview Questions ]
a => [ Spring Interview Questions ]
a => [ Hibernate Interview Questions ]
a => [ AWS Interview Questions ]
a => [ Accounting Interview Questions ]
h2 => [ Learn Latest Tutorials ]
p => [ Splunk ]
p => [ SPSS ]
p => [ Swagger ]
p => [ Transact-SQL ]
p => [ Tumblr ]
p => [ ReactJS ]
p => [ Regex ]
p => [ Reinforcement Learning ]
p => [ R Programming ]
p => [ RxJS ]
p => [ React Native ]
p => [ Python Design Patterns ]
p => [ Python Pillow ]
p => [ Python Turtle ]
p => [ Keras ]
h2 => [ Preparation ]
p => [ Aptitude ]
p => [ Reasoning ]
p => [ Verbal Ability ]
p => [ Interview Questions ]
p => [ Company Questions ]
h2 => [ Trending Technologies ]
p => [ Artificial Intelligence ]
p => [ AWS ]
p => [ Selenium ]
p => [ Cloud Computing ]
p => [ Hadoop ]
p => [ ReactJS ]
p => [ Data Science ]
p => [ Angular 7 ]
p => [ Blockchain ]
p => [ Git ]
p => [ Machine Learning ]
p => [ DevOps ]
h2 => [ B.Tech / MCA ]
p => [ DBMS ]
p => [ Data Structures ]
p => [ DAA ]
p => [ Operating System ]
p => [ Computer Network ]
p => [ Compiler Design ]
p => [ Computer Organization ]
p => [ Discrete Mathematics ]
p => [ Ethical Hacking ]
p => [ Computer Graphics ]
p => [ Software Engineering ]
p => [ Web Technology ]
p => [ Cyber Security ]
p => [ Automata ]
p => [ C Programming ]
p => [ C++ ]
p => [ Java ]
p => [ .Net ]
p => [ Python ]
p => [ Programs ]
p => [ Control System ]
p => [ Data Mining ]
p => [ Data Warehouse ]
