
div => [ 
 ]
h1 => [ Algorithm Interview Questions and Answers ]
p => [ An algorithm is an integral part of any process so that interviewers will ask you many questions related to the algorithm.  ]
p => [  Here is the list of some most asked  algorithm interview questions and their answer . These questions are also beneficial for academic and competitive exams perspective.  ]
h3 => [ 1) What is an algorithm? What is the need for an algorithm? ]
p => [ An algorithm is a well-defined computational procedure that takes some values or the set of values, as an input and produces a set of values or some values, as an output. ]
strong => [ Need for Algorithm ]
p => [ The algorithm provides the basic idea of the problem and an approach to solve it. Some reasons to use an algorithm are as follows. ]
li => [ The algorithm improves the efficiency of an existing technique. ]
li => [ To compare the performance of the algorithm with respect to other techniques. ]
li => [ The algorithm gives a strong description of requirements and goal of the problems to the designer. ]
li => [ The algorithm provides a reasonable understanding of the flow of the program. ]
li => [ The algorithm measures the performance of the methods in different cases (Best cases, worst cases, average cases). ]
li => [ The algorithm identifies the resources (input/output, memory) cycles required by the algorithm. ]
li => [ With the help of an algorithm, we can measure and analyze the complexity time and space of the problems. ]
li => [ The algorithm also reduces the cost of design. ]
h3 => [ 2) What is the Complexity of Algorithm? ]
p => [ The complexity of the algorithm is a way to classify how efficient an algorithm is compared to alternative ones. Its focus is on how execution time increases with the data set to be processed. The computational complexity of the algorithm is important in computing. ]
p => [ It is very suitable to classify algorithm based on the relative amount of time or relative amount of space they required and specify the growth of time/ space requirement as a function of input size. ]
strong => [ Time complexity ]
p => [ Time complexity is a Running time of a program as a function of the size of the input. ]
strong => [ Space complexity ]
p => [ Space complexity analyzes the algorithms, based on how much space an algorithm needs to complete its task. Space complexity analysis was critical in the early days of computing (when storage space on the computer was limited).  ]
p => [ Nowadays, the problem of space rarely occurs because space on the computer is broadly enough. ]
p => [ We achieve the following types of analysis for complexity ]
strong => [ Worst-case: f(n) ]
p => [ It is defined by the maximum number of steps taken on any instance of size n. ]
strong => [ Best-case: f(n) ]
p => [ It is defined by the minimum number of steps taken on any instance of size n. ]
strong => [ Average-case: f(n) ]
p => [ It is defined by the average number of steps taken on any instance of size n. ]
h3 => [ 3) Write an algorithm to reverse a string. For example, if my string is "uhsnamiH" then my result will be "Himanshu". ]
p => [ Algorithm to reverse a string. ]
p => [  Step1:  start ]
p => [  Step2:  Take two variable i and j ]
p => [  Step3:  do length (string)-1, to set J at last position ]
p => [  Step4:  do string [0], to set i on the first character. ]
p => [  Step5:  string [i] is interchanged with string[j] ]
p => [  Step6:  Increment i by 1 ]
p => [  Step7:  Increment j by 1 ]
p => [  Step8:  if i&gt;j then go to step3 ]
p => [  Step9:  Stop ]
h3 => [ 4) Write an algorithm to insert a node in a sorted linked list. ]
p => [ Algorithm to insert a node in a sorted linked list. ]
strong => [ Case1: ]
p => [ Check if the linked list is empty then set the node as head and return it. ]
strong => [ Case2: ]
p => [ Insert the new node in middle ]
strong => [ Case3: ]
p => [ Insert a node at the end ]
h3 => [ 5) What are the Asymptotic Notations? ]
p => [ Asymptotic analysis is used to measure the efficiency of an algorithm that doesn't depend on machine-specific constants and prevents the algorithm from comparing the time taking algorithm. Asymptotic notation is a mathematical tool that is used to represent the time complexity of algorithms for asymptotic analysis.  ]
p => [ The three most used asymptotic notation is as follows. ]
strong => [ θ Notation ]
p => [ θ Notation defines the exact asymptotic behavior. To define a behavior, it bounds functions from above and below. A convenient way to get Theta notation of an expression is to drop low order terms and ignore leading constants. ]
strong => [ Big O Notation ]
p => [  The Big O notation bounds a function from above, it defines an upper bound of an algorithm. Let's consider the case of insertion sort; it takes linear time in the best case and quadratic time in the worst case. The time complexity of insertion sort is O(n 2 ). It is useful when we only have upper bound on time complexity of an algorithm. ]
strong => [ Ω Notation ]
p => [  Just like Big O notation provides an asymptotic upper bound, the  Ω Notation  provides an asymptotic lower bound on a function. It is useful when we have lower bound on time complexity of an algorithm. ]
h3 => [ 6) Explain the Bubble sort algorithm? ]
p => [ Bubble sort is the simplest sorting algorithm among all sorting algorithm. It repeatedly works by swapping the adjacent elements if they are in the wrong order.  ]
p => [ e.g. ]
p => [ (72538) we have this array for sorting.  ]
strong => [ Pass1: ]
p => [  ( 72 538) -&gt; (27538) swap 7 and 2. 
(2 75 38) -&gt; (25738) swap 7 and 5. 
(25 73 8) -&gt; (25378) swap 7 and 3. 
(253 78 ) -&gt; (25378) algorithm does not swap 7 and 8 because 7&lt;8. ]
strong => [ Pass2:  ]
p => [  (2 5 378) -&gt; (25378) algorithm does not swap 2 and 5 because 2&lt;5. 
(2 53 78) -&gt; (23578) swap 3 and 5. 
(23 57 8) -&gt; (23578) algorithm does not swap 5 and 7 because 5&lt;7. 
(235 78 ) -&gt; (23578) algorithm does not swap 7 and 8 because 7&lt;8. ]
p => [ Here, the sorted element is (23578). ]
h3 => [ 7) How to swap two integers without swapping the temporary variable in Java? ]
p => [ It's a very commonly asked trick question. There are many ways to solve this problem.  ]
p => [ But the necessary condition is we have to solve it without swapping the temporary variable. ]
p => [ If we think about integer overflow and consider its solution, then it creates an excellent impression in the eye of interviewers. ]
p => [ Suppose we have two integers I and j, the value of i=7 and j=8 then how will you swap them without using a third variable. This is a journal problem. ]
p => [ We need to do this using Java programming constructs. We can swap numbers by performing some mathematical operations like addition, subtraction, multiplication, and division. But maybe it will create the problem of integer overflow.  ]
strong => [ Using addition and subtraction  ]
p => [ It is a nice trick. But in this trick, the integer will overflow if the addition is more than the maximum value of int primitive as defined by Integer.MAX_VALUE and if subtraction is less than minimum value i.e., Integer.MIN_VALUE. ]
strong => [ Using XOR trick ]
p => [ Another solution to swap two integers without using a third variable (temp variable) is widely recognized as the best solution, as it will also work in a language which doesn't handle integer overflow like Java example C, C++. Java supports several bitwise operators. One of them is XOR (denoted by ^). ]
h3 => [ 8) What is a Hash Table? How can we use this structure to find all anagrams in a dictionary? ]
p => [ A Hash table is a data structure for storing values to keys of arbitrary type. The Hash table consists of an index into an array by using a Hash function. Indexes are used to store the elements. We assign each possible element to a bucket by using a hash function. Multiple keys can be assigned to the same bucket, so all the key and value pairs are stored in lists within their respective buckets. Right hashing function has a great impact on performance. ]
p => [ To find all anagrams in a dictionary, we have to group all words that contain the same set of letters in them. So, if we map words to strings representing their sorted letters, then we could group words into lists by using their sorted letters as a key. ]
p => [ The hash table contains lists mapped to strings. For each word, we add it to the list at the suitable key, or create a new list and add it to it. ]
h3 => [ 9) What is Divide and Conquer algorithms? ]
p => [ Divide and Conquer is not an algorithm; it's a pattern for the algorithm. It is designed in a way as to take dispute on a huge input, break the input into minor pieces, and decide the problem for each of the small pieces. Now merge all of the piecewise solutions into a global solution. This strategy is called divide and conquer.  ]
strong => [ Divide and conquer uses the following steps to make a dispute on an algorithm. ]
p => [  Divide:  In this section, the algorithm divides the original problem into a set of subproblems. ]
p => [  Conquer:  In this section, the algorithm solves every subproblem individually.  ]
p => [  Combine:  In this section, the algorithm puts together the solutions of the subproblems to get the solution to the whole problem. ]
h3 => [ 10) Explain the BFS algorithm? ]
p => [ BFS (Breadth First Search) is a graph traversal algorithm. It starts traversing the graph from the root node and explores all the neighboring nodes. It selects the nearest node and visits all the unexplored nodes. The algorithm follows the same procedure for each of the closest nodes until it reaches the goal state. ]
strong => [ Algorithm ]
p => [  Step1:  Set status=1 (ready state) ]
p => [  Step2:  Queue the starting node A and set its status=2, i.e. (waiting state)  ]
p => [  Step3:  Repeat steps 4 and 5 until the queue is empty. ]
p => [  Step4:  Dequeue a node N and process it and set its status=3, i.e. (processed state) ]
p => [  Step5:  Queue all the neighbors of N that are in the ready state (status=1) and set their status =2 (waiting state) 
[Stop Loop] ]
p => [  Step6:  Exit ]
h3 => [ 11) What is Dijkstra's shortest path algorithm? ]
p => [ Dijkstra's algorithm is an algorithm for finding the shortest path from a starting node to the target node in a weighted graph. The algorithm makes a tree of shortest paths from the starting vertex and source vertex to all other nodes in the graph. ]
p => [ Suppose you want to go from home to office in the shortest possible way. You know some roads are heavily congested and challenging to use this, means these edges have a large weight. In Dijkstra's algorithm, the shortest path tree found by the algorithm will try to avoid edges with larger weights. ]
h3 => [ 12) Give some examples of Divide and Conquer algorithm? ]
p => [ Some problems that use Divide and conquer algorithm to find their solution are listed below. ]
li => [ Merge Sort ]
li => [ Quick Sort ]
li => [ Binary Search ]
li => [ Strassen's Matrix Multiplication ]
li => [ Closest pair (points) ]
h3 => [ 13) What are Greedy algorithms? Give some example of it? ]
p => [ A greedy algorithm is an algorithmic strategy which is made for the best optimal choice at each sub stage with the goal of this, eventually leading to a globally optimum solution. This means that the algorithm chooses the best solution at the moment without regard for consequences. ]
p => [ In other words, an algorithm that always takes the best immediate, or local, solution while finding an answer.  ]
p => [ Greedy algorithms find the overall, ideal solution for some idealistic problems, but may discover less-than-ideal solutions for some instances of other problems. ]
p => [ Below is a list of algorithms that finds their solution with the use of the Greedy algorithm. ]
li => [ Travelling Salesman Problem ]
li => [ Prim's Minimal Spanning Tree Algorithm ]
li => [ Kruskal's Minimal Spanning Tree Algorithm ]
li => [ Dijkstra's Minimal Spanning Tree Algorithm ]
li => [ Graph - Map Coloring ]
li => [ Graph - Vertex Cover ]
li => [ Knapsack Problem ]
li => [ Job Scheduling Problem ]
h3 => [ 14) What is a linear search? ]
p => [ Linear search is used on a group of items. It relies on the technique of traversing a list from start to end by visiting properties of all the elements that are found on the way. ]
p => [ For example, suppose an array of with some integer elements. You should find and print the position of all the elements with their value. Here, the linear search acts in a flow like matching each element from the beginning of the list to the end of the list with the integer, and if the condition is `True then printing the position of the element.' ]
strong => [ Implementing Linear Search ]
p => [ Below steps are required to implement the linear search. ]
p => [  Step1:  Traverse the array using  for loop . ]
p => [  Step2:  In every iteration, compare the target value with the current value of the array ]
p => [  Step3:  If the values match, return the current index of the array ]
p => [  Step4:  If the values do not match, shift on to the next array element. ]
p => [  Step5:  If no match is found, return -1 ]
h3 => [ 15) What is a Binary Search Tree?  ]
p => [ The binary search tree is a special type of data structure which has the following properties. ]
li => [ Nodes which are less than root will be in the left subtree. ]
li => [ Nodes which are greater than root (i.e., contains more value) will be right subtree. ]
li => [ A binary search tree should not have duplicate nodes. ]
li => [ Both sides subtree (i.e., left and right) also should be a binary search tree. ]
h3 => [ 16) Write an algorithm to insert a node in the Binary search tree? ]
p => [ Insert node operation is a smooth operation. You need to compare it with the root node and traverse left (if smaller) or right (if greater) according to the value of the node to be inserted. ]
strong => [ Algorithm: ]
li => [ Make the root node as the current node ]
li => [ If it has left child, then traverse left ]
li => [ If it does not have left child, insert node here ]
li => [ If it has the right child, traverse right ]
li => [ If it does not have the right child, insert node here. ]
h3 => [ 17) How to count leaf nodes of the binary tree? ]
strong => [ Algorithm- ]
p => [ Steps for counting the number of leaf nodes are: ]
li => [ If the node is null (contains null values) then return 0. ]
li => [ If encountered leaf node. Left is null and node Right is null then return 1. ]
li => [ Recursively calculate the number of leaf nodes using ]
p => [ No. of leaf nodes= no of leaf nodes in left subtree + number of leaf nodes in the right subtree. ]
h3 => [ 18) How to find all possible words in a board of characters (Boggle game)? ]
p => [ In the given dictionary, a process to do a lookup in the dictionary and an M x N board where every cell has a single character. Identify all possible words that can be formed by order of adjacent characters. Consider that we can move to any of the available 8 adjacent characters, but a word should not have multiple instances of the same cell. ]
strong => [ Example: ]
strong => [ Output: ]
h3 => [ 19) Write an algorithm to insert a node in a link list? ]
strong => [ Algorithm ]
li => [ Check If the Linked list does not have any value then make the node as head and return it ]
li => [ Check if the value of the node to be inserted is less than the value of the head node, then insert the node at the start and make it head. ]
li => [ In a loop, find the appropriate node after which the input node is to be inserted. To find the just node start from the head, keep forwarding until you reach a node whose value is greater than the input node. The node just before is the appropriate node.	 ]
li => [ Insert the node after the proper node found in step 3. ]
h3 => [ 20) How to delete a node in a given link list? Write an algorithm and a program? ]
p => [ Write a function to delete a given node from a Singly Linked List. The function must follow the following constraints: ]
li => [ The function must accept a pointer to the start node as the first argument and node to be deleted as the second argument, i.e., a pointer to head node is not global. ]
li => [ The function should not return a pointer to the head node. ]
li => [ The function should not accept pointer to pointer to head node. ]
p => [ We may assume that the Linked List never becomes empty. ]
p => [ Suppose the function name is delNode(). In a direct implementation, the function needs to adjust the head pointer when the node to be deleted the first node.  ]
strong => [ C program for deleting a node in Linked List  ]
p => [ We will handle the case when the first node to be deleted then we copy the data of the next node to head and delete the next node. In other cases when a deleted node is not the head node can be handled generally by finding the previous node.  ]
strong => [ Output: ]
h3 => [ 21) Write a c program to merge a link list into another at an alternate position? ]
p => [ We have two linked lists, insert nodes of the second list into the first list at substitute positions of the first list. ]
strong => [ Example  ]
p => [ if first list is 1-&gt;2-&gt;3 and second is 12-&gt;10-&gt;2-&gt;4-&gt;6, the first list should become 1-&gt;12-&gt;2-&gt;10-&gt;17-&gt;3-&gt;2-&gt;4-&gt;6 and second list should become empty. The nodes of the second list should only be inserted when there are positions available. ]
p => [ Use of extra space is not allowed i.e., insertion must be done in a place. Predictable time complexity is O(n) where n is number of nodes in first list. ]
strong => [ Output: ]
h3 => [ 22) Explain how the encryption algorithm works? ]
p => [ Encryption is the technique of converting plaintext into a secret code format it is also called as "Ciphertext." To convert the text, the algorithm uses a string of bits called as "keys" for calculations. The larger the key, the higher the number of potential patterns for Encryption. Most of the algorithm use codes fixed blocks of input that have a length of about 64 to 128 bits, while some uses stream method for encryption. ]
h3 => [ 23) What Are The Criteria Of Algorithm Analysis? ]
p => [ An algorithm is generally analyzed by two factors. ]
li => [ Time complexity ]
li => [ Space complexity ]
p => [  Time complexity  deals with the quantification of the amount of time taken by a set of code or algorithm to process or run as a function of the amount of input. In other words, the time complexity is efficiency or how long a program function takes to process a given input. ]
p => [  Space complexity  is the amount of memory used by the algorithm to execute and produce the result. ]
h3 => [ 24) What are the differences between stack and Queue? ]
p => [ Stack and Queue both are non-primitive data structure used for storing data elements and are based on some real-world equivalent. ]
p => [ Let's have a look at key differences based on the following parameters. ]
strong => [ Working principle ]
p => [ The significant difference between stack and queue is that stack uses LIFO (Last in First Out) method to access and add data elements whereas Queue uses FIFO (First in first out) method to obtain data member. ]
strong => [ Structure ]
p => [ In Stack, the same end is used to store and delete elements, but in Queue, one end is used for insertion, i.e., rear end and another end is used for deletion of elements. ]
strong => [ Number of pointers used ]
p => [ Stack uses one pointer whereas Queue uses two pointers (in the simple case). ]
strong => [ Operations performed ]
p => [ Stack operates as Push and pop while Queue operates as Enqueue and dequeuer. ]
strong => [ Variants ]
p => [ Stack does not have variants while Queue has variants like a circular queue, Priority queue, doubly ended Queue. ]
strong => [ Implementation ]
p => [ The stack is simpler while Queue is comparatively complex.  ]
h3 => [ 25) What is the difference between the Singly Linked List and Doubly Linked List data structure?  ]
p => [ This is a traditional interview question on the data structure. The major difference between the singly linked list and the doubly linked list is the ability to traverse. ]
p => [ You cannot traverse back in a singly linked list because in it a node only points towards the next node and there is no pointer to the previous node. ]
p => [ On the other hand, the doubly linked list allows you to navigate in both directions in any linked list because it maintains two pointers towards the next and previous node. ]
a => [ Interview Tips ]
a => [ Job/HR Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ jQuery Interview Questions ]
a => [ Java Basics Interview Questions ]
a => [ Java OOPs Interview Questions ]
a => [ Servlet Interview Questions ]
a => [ JSP Interview Questions ]
span => [ Spring Interview Questions ]
span => [ Hibernate Interview Questions ]
span => [ PL/SQL Interview Questions ]
span => [ SQL Interview Questions ]
span => [ Oracle Interview Questions ]
span => [ Android Interview Questions ]
span => [ SQL Server Interview Questions ]
span => [ MySQL Interview Questions ]
h2 => [ You may also like: ]
a => [ Java Interview Questions ]
a => [ SQL Interview Questions ]
a => [ Python Interview Questions ]
a => [ JavaScript Interview Questions ]
a => [ Angular Interview Questions ]
a => [ Selenium Interview Questions ]
a => [ Spring Boot Interview Questions ]
a => [ HR Interview Questions ]
a => [ C Programming Interview Questions ]
a => [ C++ Interview Questions ]
a => [ Data Structure Interview Questions ]
a => [ DBMS Interview Questions ]
a => [ HTML Interview Questions ]
a => [ IAS Interview Questions ]
a => [ Manual Testing Interview Questions ]
a => [ OOPs Interview Questions ]
a => [ .Net Interview Questions ]
a => [ C# Interview Questions ]
a => [ ReactJS Interview Questions ]
a => [ Networking Interview Questions ]
a => [ PHP Interview Questions ]
a => [ CSS Interview Questions ]
a => [ Node.js Interview Questions ]
a => [ Spring Interview Questions ]
a => [ Hibernate Interview Questions ]
a => [ AWS Interview Questions ]
a => [ Accounting Interview Questions ]
h2 => [ Learn Latest Tutorials ]
p => [ Splunk ]
p => [ SPSS ]
p => [ Swagger ]
p => [ Transact-SQL ]
p => [ Tumblr ]
p => [ ReactJS ]
p => [ Regex ]
p => [ Reinforcement Learning ]
p => [ R Programming ]
p => [ RxJS ]
p => [ React Native ]
p => [ Python Design Patterns ]
p => [ Python Pillow ]
p => [ Python Turtle ]
p => [ Keras ]
h2 => [ Preparation ]
p => [ Aptitude ]
p => [ Reasoning ]
p => [ Verbal Ability ]
p => [ Interview Questions ]
p => [ Company Questions ]
h2 => [ Trending Technologies ]
p => [ Artificial Intelligence ]
p => [ AWS ]
p => [ Selenium ]
p => [ Cloud Computing ]
p => [ Hadoop ]
p => [ ReactJS ]
p => [ Data Science ]
p => [ Angular 7 ]
p => [ Blockchain ]
p => [ Git ]
p => [ Machine Learning ]
p => [ DevOps ]
h2 => [ B.Tech / MCA ]
p => [ DBMS ]
p => [ Data Structures ]
p => [ DAA ]
p => [ Operating System ]
p => [ Computer Network ]
p => [ Compiler Design ]
p => [ Computer Organization ]
p => [ Discrete Mathematics ]
p => [ Ethical Hacking ]
p => [ Computer Graphics ]
p => [ Software Engineering ]
p => [ Web Technology ]
p => [ Cyber Security ]
p => [ Automata ]
p => [ C Programming ]
p => [ C++ ]
p => [ Java ]
p => [ .Net ]
p => [ Python ]
p => [ Programs ]
p => [ Control System ]
p => [ Data Mining ]
p => [ Data Warehouse ]
